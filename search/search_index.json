{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to Note Pro For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-note-pro","text":"For full documentation visit mkdocs.org .","title":"Welcome to Note Pro"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs help - Print this help message.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"daily-plans/plans-temp/","text":"Temporary","title":"Temporary"},{"location":"daily-plans/plans-temp/#temporary","text":"","title":"Temporary"},{"location":"daily-plans/plans-version-1.1/","text":"Plans for a wonderful day (version 1) List View Items Plans for a wonderful day (version 1) List View Items Time planning Ranking Social Network Ranking Coding Website Ranking Learning Knowledge Story about improving skill Time planning 7 a.m : Starting a day and thinking about dreams (not girls). 7.30 a.m : Go to school with highspeed (the first lesson starts at 7.30 a.m ). 8 -> 9.45 a.m : Learning at school. Get knowledge (not sleep). 10 a.m : Go to Youthdev Campany. It take me 30 - minutes and i stay at campany at 10.45 a.m 11 a.m : Get list of stories (medium + twitter) to read. View Odoo for my daily mission. View pm.youthdev.net to find my task. Have a daily standup with dat.hoang. 11 -> 12.30 a.m :Reading some of stories which is pinned. I will update my document with overview abour stories (markdown + pin link to web story) and my Odoo's task . 12.35 -> 1 p.m : Go out camany to have a lunch. Playing with twitter. 1 -> 1.15 p.m : Get a cup of milk cafe and go back campany to work.Reading about new technique after writing overview to own note. 1.20 -> 2 p.m : Reading a story from some books of Trung Nguyen Cafe. 2 p.m -> 6 p.m : Crazy and Work with high spirits. After i learn a new knowledge, i will pin web's link to my docs as same as some of stories. 6 -> 8 p.m : Eating Dinner and Reading again Stories I read that day. Note sumary and update to my docs over pages which haven't been commited yet. (strick for get new knowledge more benifits). 8 -> 11 p.m : solving a some issues for coding of techniques. improve them for some things better. 11 -> 12 p.m : Get a cup of milk cafe to think about the future. Find values of mine to get things better for new day. 0 -> 3 a.m : Improve My Skills. (coding, algorithm, English). Ranking Social Network Medium Twitter Channel 9 Dev.to Stackoverflow Microsoft Dev Blogs + Xamarin Developers XamGirl XamBoy XamarinInsiders Ranking Coding Website Hackerrank Codingforces Topcoder LeetCode LintCode Ranking Learning Knowledge Geeks For Geeks .NET Foundation Microsoft Courses Story about improving skill Learning deep for improving code. Learning document and coding some lines cool After reading a story, create template of markdown file, and give link to content (pin link and not commit). Go home reading some stories again and note sumay to my docs. Commit and push docs to github and vsts. Improve power of my docs, help it run automatic and async with more enviroment. Manage task at Odoo's task .","title":"Version 1"},{"location":"daily-plans/plans-version-1.1/#plans-for-a-wonderful-day-version-1","text":"","title":"Plans for a wonderful day (version 1)"},{"location":"daily-plans/plans-version-1.1/#list-view-items","text":"Plans for a wonderful day (version 1) List View Items Time planning Ranking Social Network Ranking Coding Website Ranking Learning Knowledge Story about improving skill","title":"List View Items"},{"location":"daily-plans/plans-version-1.1/#time-planning","text":"7 a.m : Starting a day and thinking about dreams (not girls). 7.30 a.m : Go to school with highspeed (the first lesson starts at 7.30 a.m ). 8 -> 9.45 a.m : Learning at school. Get knowledge (not sleep). 10 a.m : Go to Youthdev Campany. It take me 30 - minutes and i stay at campany at 10.45 a.m 11 a.m : Get list of stories (medium + twitter) to read. View Odoo for my daily mission. View pm.youthdev.net to find my task. Have a daily standup with dat.hoang. 11 -> 12.30 a.m :Reading some of stories which is pinned. I will update my document with overview abour stories (markdown + pin link to web story) and my Odoo's task . 12.35 -> 1 p.m : Go out camany to have a lunch. Playing with twitter. 1 -> 1.15 p.m : Get a cup of milk cafe and go back campany to work.Reading about new technique after writing overview to own note. 1.20 -> 2 p.m : Reading a story from some books of Trung Nguyen Cafe. 2 p.m -> 6 p.m : Crazy and Work with high spirits. After i learn a new knowledge, i will pin web's link to my docs as same as some of stories. 6 -> 8 p.m : Eating Dinner and Reading again Stories I read that day. Note sumary and update to my docs over pages which haven't been commited yet. (strick for get new knowledge more benifits). 8 -> 11 p.m : solving a some issues for coding of techniques. improve them for some things better. 11 -> 12 p.m : Get a cup of milk cafe to think about the future. Find values of mine to get things better for new day. 0 -> 3 a.m : Improve My Skills. (coding, algorithm, English).","title":"Time planning"},{"location":"daily-plans/plans-version-1.1/#ranking-social-network","text":"Medium Twitter Channel 9 Dev.to Stackoverflow Microsoft Dev Blogs + Xamarin Developers XamGirl XamBoy XamarinInsiders","title":"Ranking Social Network"},{"location":"daily-plans/plans-version-1.1/#ranking-coding-website","text":"Hackerrank Codingforces Topcoder LeetCode LintCode","title":"Ranking Coding Website"},{"location":"daily-plans/plans-version-1.1/#ranking-learning-knowledge","text":"Geeks For Geeks .NET Foundation Microsoft Courses","title":"Ranking Learning Knowledge"},{"location":"daily-plans/plans-version-1.1/#story-about-improving-skill","text":"Learning deep for improving code. Learning document and coding some lines cool After reading a story, create template of markdown file, and give link to content (pin link and not commit). Go home reading some stories again and note sumay to my docs. Commit and push docs to github and vsts. Improve power of my docs, help it run automatic and async with more enviroment. Manage task at Odoo's task .","title":"Story about improving skill"},{"location":"daily-plans/soft-skills-for-learning/","text":"Soft Skills for Learning. Reading document before working. After reading let's note. Create Sub folder for options have child. Help for managing document and visual. create file index.md to view over features. Create a root page for storing image. name extensionn with type of resources. Thinking about my issues while writing blog or document","title":"Soft Skills for Learning"},{"location":"daily-plans/soft-skills-for-learning/#soft-skills-for-learning","text":"Reading document before working. After reading let's note. Create Sub folder for options have child. Help for managing document and visual. create file index.md to view over features. Create a root page for storing image. name extensionn with type of resources. Thinking about my issues while writing blog or document","title":"Soft Skills for Learning."},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/","text":"Writing YAML This document describes the most important features of YAML for use in CircleCI configuration. How to Write YAML See Also Overview YAML is a human-friendly data serialization standard for all programming languages. It is a strict superset of JSON , another data seralizationn languages. This means it can do everything JSON can.. and more. Circle configuration is stored in a single YAML file located at ~/.circleci/config.yml , where ~ is the root of your project;s directory. Since most of your work with CircleCI occures in this file, it is important to understand the basixs of YAML formatting. How to Write YAML the basic structure of YAML file is a hash map and consists of one or more key-value pairs. key: value you can set another key-value pair as a value by indenting the nested key. key: anothe_key: \"another value\" Multi-line Strings if the value a multi-line string, use the > character, followed by any number of lines. this is especially useful for lengthy commends. haiku: > Consider me As one who loved poetry And persimmons. Note : Quotes are not necessary when using multiline strings. Sequences Keys and values are not restricted to scalars . You may also map a scalar to a sequence. scalar: - never - gonna - give - you - up Items in sequences can also be key-value pairs. simulation: - within: \"a simulation\" - without: a_glitch: \"in the matrix\" Note : Remember to properly indent a key-value when it is the value of an item in a sequence. Achors and Aliases To DRY up your config.yml , use anchors and aliases. Anchors are indentified by an & character, and aliases by an * character. song: - &name Al - You - can - call - me - *name when the a bove list is read by a YAML parser, the literal oytput looks like this. song: - Al - You - can - call - me - Al Mergin Maps Anchors and aliases work for scalar values, but to save maps or sequences, use << to inject the alias. default: &default school: hogwarts harry: <<: *default house: gryffindor draco: <<: *default house: slytherin You can also merge multi maps. name: &harray_name first_name: Harry last_name: Potter address: &harry_address street: 4, Privet Drive district: Little Whinging county: Surrey country: England harry_data: <<: [*harry_name, *harry_address] Note : As mentioned in a YAML repository issue , it is possible to merge maps, but not sequences (also called arrays or lists). for more complex example. see this gist . See Also while YAML has several other feature, the examplws above should be enough to get you started with YAML and keep your CircleCI configuration concise. if you are hungry for moree knowledge, here a few ideas. For a concrete example of keys and values, see the Configuring CircleCI document. If you are unsure whether your config.yml is value YAML, run it through a validator . CircleCI has also developed \"orbs,\" which enable you to use pre-configured and tested packages of configuration elements that you can use in our cnfiguration workflow. Utilizing DRY (Don't Repeat Yourself), orbs enable you to quickly and easily incorporate configuration elements (jobs, executors, commands) in your workflow. For more detailed information about orb: Refer to Orb introduction , for a high-level overview of orbs. Refer to Using Orbs , for more about how to use existing orbs. Refer to Creating Orbs , where you will find step-by-step instructions on how to create your own orb. Refer to Reusing Config for more detailsed examples of reusable orbs, commands, parameters, and executors. For a more exhaustive overvire of YAML, LEarn X in Y Minutes has a great summary.","title":"Writing YAML"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#writing-yaml","text":"This document describes the most important features of YAML for use in CircleCI configuration. How to Write YAML See Also","title":"Writing YAML"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#overview","text":"YAML is a human-friendly data serialization standard for all programming languages. It is a strict superset of JSON , another data seralizationn languages. This means it can do everything JSON can.. and more. Circle configuration is stored in a single YAML file located at ~/.circleci/config.yml , where ~ is the root of your project;s directory. Since most of your work with CircleCI occures in this file, it is important to understand the basixs of YAML formatting.","title":"Overview"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#how-to-write-yaml","text":"the basic structure of YAML file is a hash map and consists of one or more key-value pairs. key: value you can set another key-value pair as a value by indenting the nested key. key: anothe_key: \"another value\"","title":"How to Write YAML"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#multi-line-strings","text":"if the value a multi-line string, use the > character, followed by any number of lines. this is especially useful for lengthy commends. haiku: > Consider me As one who loved poetry And persimmons. Note : Quotes are not necessary when using multiline strings.","title":"Multi-line Strings"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#sequences","text":"Keys and values are not restricted to scalars . You may also map a scalar to a sequence. scalar: - never - gonna - give - you - up Items in sequences can also be key-value pairs. simulation: - within: \"a simulation\" - without: a_glitch: \"in the matrix\" Note : Remember to properly indent a key-value when it is the value of an item in a sequence.","title":"Sequences"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#achors-and-aliases","text":"To DRY up your config.yml , use anchors and aliases. Anchors are indentified by an & character, and aliases by an * character. song: - &name Al - You - can - call - me - *name when the a bove list is read by a YAML parser, the literal oytput looks like this. song: - Al - You - can - call - me - Al","title":"Achors and Aliases"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#mergin-maps","text":"Anchors and aliases work for scalar values, but to save maps or sequences, use << to inject the alias. default: &default school: hogwarts harry: <<: *default house: gryffindor draco: <<: *default house: slytherin You can also merge multi maps. name: &harray_name first_name: Harry last_name: Potter address: &harry_address street: 4, Privet Drive district: Little Whinging county: Surrey country: England harry_data: <<: [*harry_name, *harry_address] Note : As mentioned in a YAML repository issue , it is possible to merge maps, but not sequences (also called arrays or lists). for more complex example. see this gist .","title":"Mergin Maps"},{"location":"knowledge/dev-ops/circle-ci/writing-yaml/#see-also","text":"while YAML has several other feature, the examplws above should be enough to get you started with YAML and keep your CircleCI configuration concise. if you are hungry for moree knowledge, here a few ideas. For a concrete example of keys and values, see the Configuring CircleCI document. If you are unsure whether your config.yml is value YAML, run it through a validator . CircleCI has also developed \"orbs,\" which enable you to use pre-configured and tested packages of configuration elements that you can use in our cnfiguration workflow. Utilizing DRY (Don't Repeat Yourself), orbs enable you to quickly and easily incorporate configuration elements (jobs, executors, commands) in your workflow. For more detailed information about orb: Refer to Orb introduction , for a high-level overview of orbs. Refer to Using Orbs , for more about how to use existing orbs. Refer to Creating Orbs , where you will find step-by-step instructions on how to create your own orb. Refer to Reusing Config for more detailsed examples of reusable orbs, commands, parameters, and executors. For a more exhaustive overvire of YAML, LEarn X in Y Minutes has a great summary.","title":"See Also"},{"location":"knowledge/mobile-development/xamarin/controls-reference/","text":"Controls Reference A Description of all the visual elements used to construct a Xamarin.Forms application . The visual interface of a Xamarin.Forms application is constructed of objects that map to the native controls of each target platform. This allows platform-specific applications for iOS, Android, and the Universal Windows Platform to use Xamarin.Forms code contained in a .NET Standard library or a Shared Project . The four main control groups used to create the user interface of a Xamarin.Forms application are shown in these four articles: Pages Layouts Views Cells A Xamarin.Forms page generally occupies the entire screen. The page usually contains a layout, which contains views and possibly other layouts. Cells are specialied components used in connection with TableView and ListView . In the four articles on Pages , Layouts , Views and Cells , each type of control is described with links to its API documentation, an article describing its use (if one exists), and one or more sample programs(if they exist). Each type of control is also accompanied by a screenshot showing a page from the FormsGallery sample running on iOS, Android, and UWP devices. Below each screenshot are links to the source code fot the C# page, the quivalent Xaml page, and (when appropriate) the C# code-behind file for the Xaml page. A cell is a specialized element used for items in a table and describes how each item in a list should be rendered. The Cell class derives from Element , from which VisualElement also derives. A cell is not itself a visual element; it is instead a template for creating a visual element. Cells Xamarin.Forms supports the following cell types: TextCell A TextCell displays one or two text strings. Set the Text property and, optionally, the Detail property to these text strings. ImageCell The ImageCell displays the same information as TextCell but includes a bitmap that you set with the Source property. SwitchCell The SwitchCell contains text set with the Text ' property and on/off switch initiallly set with the Boolean On property. Handle the Onchanged event to be notified when the On property changes. EntryCell The EntryCell defines a Label property that identifies the cell and a single line of editable text in the Text property. Handle the Completed event to be notified when the user has completed the text entry. Get more information at here .","title":"Controls Reference"},{"location":"knowledge/mobile-development/xamarin/controls-reference/#controls-reference","text":"A Description of all the visual elements used to construct a Xamarin.Forms application . The visual interface of a Xamarin.Forms application is constructed of objects that map to the native controls of each target platform. This allows platform-specific applications for iOS, Android, and the Universal Windows Platform to use Xamarin.Forms code contained in a .NET Standard library or a Shared Project . The four main control groups used to create the user interface of a Xamarin.Forms application are shown in these four articles: Pages Layouts Views Cells A Xamarin.Forms page generally occupies the entire screen. The page usually contains a layout, which contains views and possibly other layouts. Cells are specialied components used in connection with TableView and ListView . In the four articles on Pages , Layouts , Views and Cells , each type of control is described with links to its API documentation, an article describing its use (if one exists), and one or more sample programs(if they exist). Each type of control is also accompanied by a screenshot showing a page from the FormsGallery sample running on iOS, Android, and UWP devices. Below each screenshot are links to the source code fot the C# page, the quivalent Xaml page, and (when appropriate) the C# code-behind file for the Xaml page. A cell is a specialized element used for items in a table and describes how each item in a list should be rendered. The Cell class derives from Element , from which VisualElement also derives. A cell is not itself a visual element; it is instead a template for creating a visual element.","title":"Controls Reference"},{"location":"knowledge/mobile-development/xamarin/controls-reference/#cells","text":"Xamarin.Forms supports the following cell types:","title":"Cells"},{"location":"knowledge/mobile-development/xamarin/controls-reference/#textcell","text":"A TextCell displays one or two text strings. Set the Text property and, optionally, the Detail property to these text strings.","title":"TextCell"},{"location":"knowledge/mobile-development/xamarin/controls-reference/#imagecell","text":"The ImageCell displays the same information as TextCell but includes a bitmap that you set with the Source property.","title":"ImageCell"},{"location":"knowledge/mobile-development/xamarin/controls-reference/#switchcell","text":"The SwitchCell contains text set with the Text ' property and on/off switch initiallly set with the Boolean On property. Handle the Onchanged event to be notified when the On property changes.","title":"SwitchCell"},{"location":"knowledge/mobile-development/xamarin/controls-reference/#entrycell","text":"The EntryCell defines a Label property that identifies the cell and a single line of editable text in the Text property. Handle the Completed event to be notified when the user has completed the text entry. Get more information at here .","title":"EntryCell"},{"location":"knowledge/mobile-development/xamarin/customizing-listview-cell-appearance/","text":"Cusomizing ListView Cell Appearence ListView presents scrollable lists, which can be customized through the use of ViewCells . ViewCells can be used for displaying text and images, indicating a true/false state and receiving user input. Built in Cells Xamarin.Forms comes with built-in cells that work for many simple applications: TextCell - for displaying text ImageCell - for displaying an image with text. Two additional cells, SwitchCell and EntryCell are available, however they aren't commonly used with ListView . See TableView for more information about these cells. TextCell TextCells are rendered as natice controls at runtime, so performace is very good compared to a custom ViewCell . TextCells are cusomizable, allowing you to set: Text : the text that shown on the first line, in large font. Detail : the text is shown underneath the first line, in a smaller font. TextColor : the color of the text. DetailColor : the color of the detail text. ImageCell ImageCell is usedful when you need to display a list of data with a visual aspect, such as a list of contacts or movies. ImageCells are customizable, allowing you to set: Text : the text that is shown on the firt line, in large font. Detail : the text that is shown underneath the first line, in a smaller font. TextColor : the color of the text. DetailColor : the color of the detail text ImageSource : the image to display next to the text. Custom Cells When the built-in cells don't provide the required layout, custom cells implemented the required layout. Build a cell with two lables that have equal weight. A TextCell would be insufficient because the TextCell has one label that is smaller. All custom cells must derive from ViewCell , the same base class that all of the built-inn cell types use. XAML The XAML to create the above layout is below: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"demoListView.ImageCellPage\"> <ContentPage.Content> <ListView x:Name=\"listView\"> <ListView.ItemTemplate> <DataTemplate> <ViewCell> <StackLayout BackgroundColor=\"#eee\" Orientation=\"Vertical\"> <StackLayout Orientation=\"Horizontal\"> <Image Source=\"{Binding image}\" /> <Label Text=\"{Binding title}\" TextColor=\"#f35e20\" /> <Label Text=\"{Binding subtitle}\" HorizontalOptions=\"EndAndExpand\" TextColor=\"#503026\" /> </StackLayout> </StackLayout> </ViewCell> </DataTemplate> </ListView.ItemTemplate> </ListView> </ContentPage.Content> </ContentPage> The XAML above is doing a lot. Let's break it down: The custom cell is nested inside a DataTemplate , which is inside ListView.ItemTemplate . ViewCell is the type of the custom cell. The child of the DataTemplate element must be of or derive from type ViewCell . Notice that inside the ViewCell , layout is managed by a StackLayout . This layout allows us to customize the backgtound color. Note that any property of StackLayout that bindable can be bound inside a custom cell, although that is not shown here. Inside the ViewCell , layout can be managed by any Xamarin.Forms layout. C# Specifying a custom cell in C# is a bit more verbose than the XAML equivalent. Let's take a look: First, define a custom cell class, with ViewCell as the base class: public class CustomCell : ViewCell { public CustomCell() { //instantiate each of our views var image = new Image (); StackLayout cellWrapper = new StackLayout (); StackLayout horizontalLayout = new StackLayout (); Label left = new Label (); Label right = new Label (); //set bindings left.SetBinding (Label.TextProperty, \"title\"); right.SetBinding (Label.TextProperty, \"subtitle\"); image.SetBinding (Image.SourceProperty, \"image\"); //Set properties for desired design cellWrapper.BackgroundColor = Color.FromHex (\"#eee\"); horizontalLayout.Orientation = StackOrientation.Horizontal; right.HorizontalOptions = LayoutOptions.EndAndExpand; left.TextColor = Color.FromHex (\"#f35e20\"); right.TextColor = Color.FromHex (\"503026\"); //add views to the view hierarchy horizontalLayout.Children.Add (image); horizontalLayout.Children.Add (left); horizontalLayout.Children.Add (right); cellWrapper.Children.Add (horizontalLayout); View = cellWrapper; } } In your constructor for the page with the ListView , set the ListView's ItemTemplate property to a new DataTemplate . public partial class ImageCellPage : ContentPage { public ImageCellPage () { InitializeComponent (); listView.ItemTemplate = new DataTemplate (typeof(CustomCell)); } } Note that the constructor for DataTemplate takes a type. The typeof operator gets the CLR type for CustomCell . Binding Context Changes When binding to a custom cell type's BindableProperty instances, the UI controls displaying the BindableProperty values should use the OnBindingContextChanged override to set the data to be displayed in each cell, rather than the cell contructor, as demonstrated in the following code example: public class CustomCell : ViewCell { Label nameLabel, ageLabel, locationLabel; public static readonly BindableProperty NameProperty = BindableProperty.Create (\"Name\", typeof(string), typeof(CustomCell), \"Name\"); public static readonly BindableProperty AgeProperty = BindableProperty.Create (\"Age\", typeof(int), typeof(CustomCell), 0); public static readonly BindableProperty LocationProperty = BindableProperty.Create (\"Location\", typeof(string), typeof(CustomCell), \"Location\"); public string Name { get { return(string)GetValue (NameProperty); } set { SetValue (NameProperty, value); } } public int Age { get { return(int)GetValue (AgeProperty); } set { SetValue (AgeProperty, value); } } public string Location { get { return(string)GetValue (LocationProperty); } set { SetValue (LocationProperty, value); } } ... protected override void OnBindingContextChanged () { base.OnBindingContextChanged (); if (BindingContext != null) { nameLabel.Text = Name; ageLabel.Text = Age.ToString (); locationLabel.Text = Location; } } } The OnBindingContextChanged override will be called when the BindingContextChanged event fires, in response to the value of the BindingContext property changing. Therefore when the BindingContext changes, the UI controls displaying the BindableProperty values should set their data. Note that the BindingContext should be checked for a null value, as this can be set by Xamarin.Forms for garbage collection, which in turn will result in the OnbindingContextChanged override being called. Alternatively, UI controls can bind to the BindableProperty instances to display their values, which removes the need to override the OnBindingContextChanged method. In XAML, binding the custom cell type to data can be achieved as shown in the following code example: <ListView x:Name=\"listView\"> <ListView.ItemTemplate> <DataTemplate> <local:CustomCell Name=\"{Binding Name}\" Age=\"{Binding Age}\" Location=\"{Binding Location}\" /> </DataTemplate> </ListView.ItemTemplate> </ListView> Get more information at here .","title":"Customizing ListView cell Appearence"},{"location":"knowledge/mobile-development/xamarin/customizing-listview-cell-appearance/#cusomizing-listview-cell-appearence","text":"ListView presents scrollable lists, which can be customized through the use of ViewCells . ViewCells can be used for displaying text and images, indicating a true/false state and receiving user input.","title":"Cusomizing ListView Cell Appearence"},{"location":"knowledge/mobile-development/xamarin/customizing-listview-cell-appearance/#built-in-cells","text":"Xamarin.Forms comes with built-in cells that work for many simple applications: TextCell - for displaying text ImageCell - for displaying an image with text. Two additional cells, SwitchCell and EntryCell are available, however they aren't commonly used with ListView . See TableView for more information about these cells.","title":"Built in Cells"},{"location":"knowledge/mobile-development/xamarin/customizing-listview-cell-appearance/#textcell","text":"TextCells are rendered as natice controls at runtime, so performace is very good compared to a custom ViewCell . TextCells are cusomizable, allowing you to set: Text : the text that shown on the first line, in large font. Detail : the text is shown underneath the first line, in a smaller font. TextColor : the color of the text. DetailColor : the color of the detail text.","title":"TextCell"},{"location":"knowledge/mobile-development/xamarin/customizing-listview-cell-appearance/#imagecell","text":"ImageCell is usedful when you need to display a list of data with a visual aspect, such as a list of contacts or movies. ImageCells are customizable, allowing you to set: Text : the text that is shown on the firt line, in large font. Detail : the text that is shown underneath the first line, in a smaller font. TextColor : the color of the text. DetailColor : the color of the detail text ImageSource : the image to display next to the text.","title":"ImageCell"},{"location":"knowledge/mobile-development/xamarin/customizing-listview-cell-appearance/#custom-cells","text":"When the built-in cells don't provide the required layout, custom cells implemented the required layout. Build a cell with two lables that have equal weight. A TextCell would be insufficient because the TextCell has one label that is smaller. All custom cells must derive from ViewCell , the same base class that all of the built-inn cell types use. XAML The XAML to create the above layout is below: <?xml version=\"1.0\" encoding=\"UTF-8\"?> <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"demoListView.ImageCellPage\"> <ContentPage.Content> <ListView x:Name=\"listView\"> <ListView.ItemTemplate> <DataTemplate> <ViewCell> <StackLayout BackgroundColor=\"#eee\" Orientation=\"Vertical\"> <StackLayout Orientation=\"Horizontal\"> <Image Source=\"{Binding image}\" /> <Label Text=\"{Binding title}\" TextColor=\"#f35e20\" /> <Label Text=\"{Binding subtitle}\" HorizontalOptions=\"EndAndExpand\" TextColor=\"#503026\" /> </StackLayout> </StackLayout> </ViewCell> </DataTemplate> </ListView.ItemTemplate> </ListView> </ContentPage.Content> </ContentPage> The XAML above is doing a lot. Let's break it down: The custom cell is nested inside a DataTemplate , which is inside ListView.ItemTemplate . ViewCell is the type of the custom cell. The child of the DataTemplate element must be of or derive from type ViewCell . Notice that inside the ViewCell , layout is managed by a StackLayout . This layout allows us to customize the backgtound color. Note that any property of StackLayout that bindable can be bound inside a custom cell, although that is not shown here. Inside the ViewCell , layout can be managed by any Xamarin.Forms layout. C# Specifying a custom cell in C# is a bit more verbose than the XAML equivalent. Let's take a look: First, define a custom cell class, with ViewCell as the base class: public class CustomCell : ViewCell { public CustomCell() { //instantiate each of our views var image = new Image (); StackLayout cellWrapper = new StackLayout (); StackLayout horizontalLayout = new StackLayout (); Label left = new Label (); Label right = new Label (); //set bindings left.SetBinding (Label.TextProperty, \"title\"); right.SetBinding (Label.TextProperty, \"subtitle\"); image.SetBinding (Image.SourceProperty, \"image\"); //Set properties for desired design cellWrapper.BackgroundColor = Color.FromHex (\"#eee\"); horizontalLayout.Orientation = StackOrientation.Horizontal; right.HorizontalOptions = LayoutOptions.EndAndExpand; left.TextColor = Color.FromHex (\"#f35e20\"); right.TextColor = Color.FromHex (\"503026\"); //add views to the view hierarchy horizontalLayout.Children.Add (image); horizontalLayout.Children.Add (left); horizontalLayout.Children.Add (right); cellWrapper.Children.Add (horizontalLayout); View = cellWrapper; } } In your constructor for the page with the ListView , set the ListView's ItemTemplate property to a new DataTemplate . public partial class ImageCellPage : ContentPage { public ImageCellPage () { InitializeComponent (); listView.ItemTemplate = new DataTemplate (typeof(CustomCell)); } } Note that the constructor for DataTemplate takes a type. The typeof operator gets the CLR type for CustomCell . Binding Context Changes When binding to a custom cell type's BindableProperty instances, the UI controls displaying the BindableProperty values should use the OnBindingContextChanged override to set the data to be displayed in each cell, rather than the cell contructor, as demonstrated in the following code example: public class CustomCell : ViewCell { Label nameLabel, ageLabel, locationLabel; public static readonly BindableProperty NameProperty = BindableProperty.Create (\"Name\", typeof(string), typeof(CustomCell), \"Name\"); public static readonly BindableProperty AgeProperty = BindableProperty.Create (\"Age\", typeof(int), typeof(CustomCell), 0); public static readonly BindableProperty LocationProperty = BindableProperty.Create (\"Location\", typeof(string), typeof(CustomCell), \"Location\"); public string Name { get { return(string)GetValue (NameProperty); } set { SetValue (NameProperty, value); } } public int Age { get { return(int)GetValue (AgeProperty); } set { SetValue (AgeProperty, value); } } public string Location { get { return(string)GetValue (LocationProperty); } set { SetValue (LocationProperty, value); } } ... protected override void OnBindingContextChanged () { base.OnBindingContextChanged (); if (BindingContext != null) { nameLabel.Text = Name; ageLabel.Text = Age.ToString (); locationLabel.Text = Location; } } } The OnBindingContextChanged override will be called when the BindingContextChanged event fires, in response to the value of the BindingContext property changing. Therefore when the BindingContext changes, the UI controls displaying the BindableProperty values should set their data. Note that the BindingContext should be checked for a null value, as this can be set by Xamarin.Forms for garbage collection, which in turn will result in the OnbindingContextChanged override being called. Alternatively, UI controls can bind to the BindableProperty instances to display their values, which removes the need to override the OnBindingContextChanged method. In XAML, binding the custom cell type to data can be achieved as shown in the following code example: <ListView x:Name=\"listView\"> <ListView.ItemTemplate> <DataTemplate> <local:CustomCell Name=\"{Binding Name}\" Age=\"{Binding Age}\" Location=\"{Binding Location}\" /> </DataTemplate> </ListView.ItemTemplate> </ListView> Get more information at here .","title":"Custom Cells"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/","text":"DataPages Controls Reference Built-in Controls HeroImage ListItem HeroImage The HeroImage control has four properties: Text Detail ImageSource Aspect <pages:HeroImage ImageSource=\"{ DynamicResource HeroImageImage }\" Text=\"Keith Ballinger\" Detail=\"Xamarin\" /> ListItem The ListItem control's layout is similar to native iOS and Android lis or table rows, however it can also used as a regular view. In the example code below it is shown hosted inside a StackLayout , but it can also be used in data-bound scolling list controls. There are five properties: Title Detail ImageSource PlaceholdImageSource Aspect <StackLayout Spacing=\"0\"> <pages:ListItemControl Detail=\"Xamarin\" ImageSource=\"{ DynamicResource UserImage }\" Title=\"Miguel de Icaza\" PlaceholdImageSource=\"{ DynamicResource IconImage }\" /> Custom Control Example The goal of this custom CardView control is to resemble the native Android CardView. It will contain three properties: Text Detail ImageSource The goal is a custom control that will look like the code below(note that a custom xmlns:local is required that references the current assembly): <local:CardView ImageSource=\"{ DynamicResource CardViewImage }\" Text=\"CardView Text\" Detail=\"CardView Detail\" /> Building the Custom CarView DataView Subclass The C# subclass of DataView defines the bindable properties for the control. public class CardView : DataView { public static readonly BindableProperty TextProperty = BindableProperty.Create (\"Text\", typeof (string), typeof (CardView), null, BindingMode.TwoWay); public string Text { get { return (string)GetValue (TextProperty); } set { SetValue (TextProperty, value); } } public static readonly BindableProperty DetailProperty = BindableProperty.Create (\"Detail\", typeof (string), typeof (CardView), null, BindingMode.TwoWay); public string Detail { get { return (string)GetValue (DetailProperty); } set { SetValue (DetailProperty, value); } } public static readonly BindableProperty ImageSourceProperty = BindableProperty.Create (\"ImageSource\", typeof (ImageSource), typeof (CardView), null, BindingMode.TwoWay); public ImageSource ImageSource { get { return (ImageSource)GetValue (ImageSourceProperty); } set { SetValue (ImageSourceProperty, value); } } public CardView() { } } Define Font, Layout, and Margins The control designer would figure out these values as part of the user-interface design for the custom control. Where platform-specific specifications are required, the OnPlatform element is used. Note that some values refer to StaticResource s - these will be defined in step 5 . <!-- CARDVIEW FONT SIZES --> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewTextFontSize\"> <On Platform=\"iOS, Android\" Value=\"15\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewDetailFontSize\"> <On Platform=\"iOS, Android\" Value=\"13\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewTextTextColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSCardViewTextTextColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidCardViewTextTextColor}\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Thickness\" x:Key=\"CardViewTextlMargin\"> <On Platform=\"iOS\" Value=\"12,10,12,4\" /> <On Platform=\"Android\" Value=\"20,0,20,5\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewDetailTextColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSCardViewDetailTextColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidCardViewDetailTextColor}\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Thickness\" x:Key=\"CardViewDetailMargin\"> <On Platform=\"iOS\" Value=\"12,0,10,12\" /> <On Platform=\"Android\" Value=\"20,0,20,20\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewBackgroundColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSCardViewBackgroundColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidCardViewBackgroundColor}\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewShadowSize\"> <On Platform=\"iOS\" Value=\"2\" /> <On Platform=\"Android\" Value=\"5\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewCornerRadius\"> <On Platform=\"iOS\" Value=\"0\" /> <On Platform=\"Android\" Value=\"4\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewShadowColor\"> <On Platform=\"iOS, Android\" Value=\"#CDCDD1\" /> </OnPlatform> Create Styles for the Control's Children Reference all the elements defined about to create the children that will be used in the custom control: <!-- EXPLICIT STYLES (will be Classes) --> <Style TargetType=\"Label\" x:Key=\"CardViewTextStyle\"> <Setter Property=\"FontSize\" Value=\"{ StaticResource CardViewTextFontSize }\" /> <Setter Property=\"TextColor\" Value=\"{ StaticResource CardViewTextTextColor }\" /> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"Margin\" Value=\"{ StaticResource CardViewTextlMargin }\" /> <Setter Property=\"HorizontalTextAlignment\" Value=\"Start\" /> </Style> <Style TargetType=\"Label\" x:Key=\"CardViewDetailStyle\"> <Setter Property=\"HorizontalTextAlignment\" Value=\"Start\" /> <Setter Property=\"TextColor\" Value=\"{ StaticResource CardViewDetailTextColor }\" /> <Setter Property=\"FontSize\" Value=\"{ StaticResource CardViewDetailFontSize }\" /> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"Margin\" Value=\"{ StaticResource CardViewDetailMargin }\" /> </Style> <Style TargetType=\"Image\" x:Key=\"CardViewImageImageStyle\"> <Setter Property=\"HorizontalOptions\" Value=\"Center\" /> <Setter Property=\"VerticalOptions\" Value=\"Center\" /> <Setter Property=\"WidthRequest\" Value=\"220\"/> <Setter Property=\"HeightRequest\" Value=\"165\"/> </Style> Create the Control Layout Template The visual design of the custom control is explicitly declared in the control template, using the resources defined above: <!--- CARDVIEW --> <ControlTemplate x:Key=\"CardViewControlControlTemplate\"> <StackLayout Spacing=\"0\" BackgroundColor=\"{ TemplateBinding BackgroundColor }\" > <!-- CARDVIEW IMAGE --> <Image Source=\"{ TemplateBinding ImageSource }\" HorizontalOptions=\"FillAndExpand\" VerticalOptions=\"StartAndExpand\" Aspect=\"AspectFill\" Style=\"{ StaticResource CardViewImageImageStyle }\" /> <!-- CARDVIEW TEXT --> <Label Text=\"{ TemplateBinding Text }\" LineBreakMode=\"WordWrap\" VerticalOptions=\"End\" Style=\"{ StaticResource CardViewTextStyle }\" /> <!-- CARDVIEW DETAIL --> <Label Text=\"{ TemplateBinding Detail }\" LineBreakMode=\"WordWrap\" VerticalOptions=\"End\" Style=\"{ StaticResource CardViewDetailStyle }\" /> </StackLayout> </ControlTemplate> Add the Theme-specific Resources Because this is a custom control, add the resources that match the theme you are using the rersource dictionary: Light Theme Colors <Color x:Key=\"iOSCardViewBackgroundColor\">#FFFFFF</Color> <Color x:Key=\"AndroidCardViewBackgroundColor\">#FFFFFF</Color> <Color x:Key=\"AndroidCardViewTextTextColor\">#030303</Color> <Color x:Key=\"iOSCardViewTextTextColor\">#030303</Color> <Color x:Key=\"AndroidCardViewDetailTextColor\">#8F8E94</Color> <Color x:Key=\"iOSCardViewDetailTextColor\">#8F8E94</Color> Dark Theme Colors <!-- CARD VIEW COLORS --> <Color x:Key=\"iOSCardViewBackgroundColor\">#404040</Color> <Color x:Key=\"AndroidCardViewBackgroundColor\">#404040</Color> <Color x:Key=\"AndroidCardViewTextTextColor\">#FFFFFF</Color> <Color x:Key=\"iOSCardViewTextTextColor\">#FFFFFF</Color> <Color x:Key=\"AndroidCardViewDetailTextColor\">#B5B4B9</Color> <Color x:Key=\"iOSCardViewDetailTextColor\">#B5B4B9</Color> Set the ControlTemplate for the CardView class Finnally, ensure the C# class created in step 1 uses the control template defined in step 4 using a Style Setter element <Style TargetType=\"local:CardView\"> <Setter Property=\"ControlTemplate\" Value=\"{ StaticResource CardViewControlControlTemplate }\" /> ... some custom styling omitted <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource CardViewBackgroundColor }\" /> </Style> Add the Control to a Page The CardView control can now be added to a page. The example below shows it hosted in a StackLayout <StackLayout Spacing=\"0\"> <local:CardView Margin=\"12,6\" ImageSource=\"{ DynamicResource CardViewImage }\" Text=\"CardView Text\" Detail=\"CardView Detail\" /> </StackLayout> More information at here .","title":"Data Pages Controls"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#datapages-controls-reference","text":"","title":"DataPages Controls Reference"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#built-in-controls","text":"HeroImage ListItem","title":"Built-in Controls"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#heroimage","text":"The HeroImage control has four properties: Text Detail ImageSource Aspect <pages:HeroImage ImageSource=\"{ DynamicResource HeroImageImage }\" Text=\"Keith Ballinger\" Detail=\"Xamarin\" />","title":"HeroImage"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#listitem","text":"The ListItem control's layout is similar to native iOS and Android lis or table rows, however it can also used as a regular view. In the example code below it is shown hosted inside a StackLayout , but it can also be used in data-bound scolling list controls. There are five properties: Title Detail ImageSource PlaceholdImageSource Aspect <StackLayout Spacing=\"0\"> <pages:ListItemControl Detail=\"Xamarin\" ImageSource=\"{ DynamicResource UserImage }\" Title=\"Miguel de Icaza\" PlaceholdImageSource=\"{ DynamicResource IconImage }\" />","title":"ListItem"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#custom-control-example","text":"The goal of this custom CardView control is to resemble the native Android CardView. It will contain three properties: Text Detail ImageSource The goal is a custom control that will look like the code below(note that a custom xmlns:local is required that references the current assembly): <local:CardView ImageSource=\"{ DynamicResource CardViewImage }\" Text=\"CardView Text\" Detail=\"CardView Detail\" />","title":"Custom Control Example"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#building-the-custom-carview","text":"","title":"Building the Custom CarView"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#dataview-subclass","text":"The C# subclass of DataView defines the bindable properties for the control. public class CardView : DataView { public static readonly BindableProperty TextProperty = BindableProperty.Create (\"Text\", typeof (string), typeof (CardView), null, BindingMode.TwoWay); public string Text { get { return (string)GetValue (TextProperty); } set { SetValue (TextProperty, value); } } public static readonly BindableProperty DetailProperty = BindableProperty.Create (\"Detail\", typeof (string), typeof (CardView), null, BindingMode.TwoWay); public string Detail { get { return (string)GetValue (DetailProperty); } set { SetValue (DetailProperty, value); } } public static readonly BindableProperty ImageSourceProperty = BindableProperty.Create (\"ImageSource\", typeof (ImageSource), typeof (CardView), null, BindingMode.TwoWay); public ImageSource ImageSource { get { return (ImageSource)GetValue (ImageSourceProperty); } set { SetValue (ImageSourceProperty, value); } } public CardView() { } }","title":"DataView Subclass"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#define-font-layout-and-margins","text":"The control designer would figure out these values as part of the user-interface design for the custom control. Where platform-specific specifications are required, the OnPlatform element is used. Note that some values refer to StaticResource s - these will be defined in step 5 . <!-- CARDVIEW FONT SIZES --> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewTextFontSize\"> <On Platform=\"iOS, Android\" Value=\"15\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewDetailFontSize\"> <On Platform=\"iOS, Android\" Value=\"13\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewTextTextColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSCardViewTextTextColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidCardViewTextTextColor}\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Thickness\" x:Key=\"CardViewTextlMargin\"> <On Platform=\"iOS\" Value=\"12,10,12,4\" /> <On Platform=\"Android\" Value=\"20,0,20,5\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewDetailTextColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSCardViewDetailTextColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidCardViewDetailTextColor}\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Thickness\" x:Key=\"CardViewDetailMargin\"> <On Platform=\"iOS\" Value=\"12,0,10,12\" /> <On Platform=\"Android\" Value=\"20,0,20,20\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewBackgroundColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSCardViewBackgroundColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidCardViewBackgroundColor}\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewShadowSize\"> <On Platform=\"iOS\" Value=\"2\" /> <On Platform=\"Android\" Value=\"5\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"x:Double\" x:Key=\"CardViewCornerRadius\"> <On Platform=\"iOS\" Value=\"0\" /> <On Platform=\"Android\" Value=\"4\" /> </OnPlatform> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"CardViewShadowColor\"> <On Platform=\"iOS, Android\" Value=\"#CDCDD1\" /> </OnPlatform>","title":"Define Font, Layout, and Margins"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#create-styles-for-the-controls-children","text":"Reference all the elements defined about to create the children that will be used in the custom control: <!-- EXPLICIT STYLES (will be Classes) --> <Style TargetType=\"Label\" x:Key=\"CardViewTextStyle\"> <Setter Property=\"FontSize\" Value=\"{ StaticResource CardViewTextFontSize }\" /> <Setter Property=\"TextColor\" Value=\"{ StaticResource CardViewTextTextColor }\" /> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"Margin\" Value=\"{ StaticResource CardViewTextlMargin }\" /> <Setter Property=\"HorizontalTextAlignment\" Value=\"Start\" /> </Style> <Style TargetType=\"Label\" x:Key=\"CardViewDetailStyle\"> <Setter Property=\"HorizontalTextAlignment\" Value=\"Start\" /> <Setter Property=\"TextColor\" Value=\"{ StaticResource CardViewDetailTextColor }\" /> <Setter Property=\"FontSize\" Value=\"{ StaticResource CardViewDetailFontSize }\" /> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"Margin\" Value=\"{ StaticResource CardViewDetailMargin }\" /> </Style> <Style TargetType=\"Image\" x:Key=\"CardViewImageImageStyle\"> <Setter Property=\"HorizontalOptions\" Value=\"Center\" /> <Setter Property=\"VerticalOptions\" Value=\"Center\" /> <Setter Property=\"WidthRequest\" Value=\"220\"/> <Setter Property=\"HeightRequest\" Value=\"165\"/> </Style>","title":"Create Styles for the Control's Children"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#create-the-control-layout-template","text":"The visual design of the custom control is explicitly declared in the control template, using the resources defined above: <!--- CARDVIEW --> <ControlTemplate x:Key=\"CardViewControlControlTemplate\"> <StackLayout Spacing=\"0\" BackgroundColor=\"{ TemplateBinding BackgroundColor }\" > <!-- CARDVIEW IMAGE --> <Image Source=\"{ TemplateBinding ImageSource }\" HorizontalOptions=\"FillAndExpand\" VerticalOptions=\"StartAndExpand\" Aspect=\"AspectFill\" Style=\"{ StaticResource CardViewImageImageStyle }\" /> <!-- CARDVIEW TEXT --> <Label Text=\"{ TemplateBinding Text }\" LineBreakMode=\"WordWrap\" VerticalOptions=\"End\" Style=\"{ StaticResource CardViewTextStyle }\" /> <!-- CARDVIEW DETAIL --> <Label Text=\"{ TemplateBinding Detail }\" LineBreakMode=\"WordWrap\" VerticalOptions=\"End\" Style=\"{ StaticResource CardViewDetailStyle }\" /> </StackLayout> </ControlTemplate>","title":"Create the Control Layout Template"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#add-the-theme-specific-resources","text":"Because this is a custom control, add the resources that match the theme you are using the rersource dictionary: Light Theme Colors <Color x:Key=\"iOSCardViewBackgroundColor\">#FFFFFF</Color> <Color x:Key=\"AndroidCardViewBackgroundColor\">#FFFFFF</Color> <Color x:Key=\"AndroidCardViewTextTextColor\">#030303</Color> <Color x:Key=\"iOSCardViewTextTextColor\">#030303</Color> <Color x:Key=\"AndroidCardViewDetailTextColor\">#8F8E94</Color> <Color x:Key=\"iOSCardViewDetailTextColor\">#8F8E94</Color> Dark Theme Colors <!-- CARD VIEW COLORS --> <Color x:Key=\"iOSCardViewBackgroundColor\">#404040</Color> <Color x:Key=\"AndroidCardViewBackgroundColor\">#404040</Color> <Color x:Key=\"AndroidCardViewTextTextColor\">#FFFFFF</Color> <Color x:Key=\"iOSCardViewTextTextColor\">#FFFFFF</Color> <Color x:Key=\"AndroidCardViewDetailTextColor\">#B5B4B9</Color> <Color x:Key=\"iOSCardViewDetailTextColor\">#B5B4B9</Color>","title":"Add the Theme-specific Resources"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#set-the-controltemplate-for-the-cardview-class","text":"Finnally, ensure the C# class created in step 1 uses the control template defined in step 4 using a Style Setter element <Style TargetType=\"local:CardView\"> <Setter Property=\"ControlTemplate\" Value=\"{ StaticResource CardViewControlControlTemplate }\" /> ... some custom styling omitted <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource CardViewBackgroundColor }\" /> </Style>","title":"Set the ControlTemplate for the CardView class"},{"location":"knowledge/mobile-development/xamarin/data-pages-controls/#add-the-control-to-a-page","text":"The CardView control can now be added to a page. The example below shows it hosted in a StackLayout <StackLayout Spacing=\"0\"> <local:CardView Margin=\"12,6\" ImageSource=\"{ DynamicResource CardViewImage }\" Text=\"CardView Text\" Detail=\"CardView Detail\" /> </StackLayout> More information at here .","title":"Add the Control to a Page"},{"location":"knowledge/mobile-development/xamarin/data-pages/","text":"Data Pages Get Started To get started building a simplw data-driven page using the DataPages Preview, follow the steps below. This demo uses a hardcoded style (\"Events\") in the Preview builds that only works with the specific JSON format in the code. Add Nuget Packages Add these Nuget packages to your Xamarin.Forms .NET Standard library and application projects: Xamarin.Forms.Pages Xamarin.Forms.Theme.Base A theme implementation Nuget(eg. Xamarin.Forms.Themes.Light) Add Theme Reference In the App.xaml file, add a custom xmlns:mytheme for the theme and ensure the theme is merged into the application's resource dictionary: <Application xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:mytheme=\"clr-namespace:Xamarin.Forms.Themes;assembly=Xamarin.Forms.Theme.Light\" x:Class=\"DataPagesDemo.App\"> <Application.Resources> <ResourceDictionary MergedWith=\"mytheme:LightThemeResources\" /> </Application.Resources> </Application> Add a XAML Page Add a new XAML page to the Xamarin.Forms application, and change the base class form ContentPage to Xamarin.Forms.Pages.ListDataPage. This has to be done in both the C# and the XAML C# file public partial class SessionDataPage : Xamarin.Forms.Pages.ListDataPage // was ContentPage { public SessionDataPage () { InitializeComponent (); } } Add the DataSource Delete the Content element and replace it with a p:ListDataPage.DataSource to populate the page with data. In the example below a remote Json data file is being loaded from a URL. Note : the preview requires a StyleClass attribute to provide rendering hints for the data source. The StyleClass=\"Events\" refers to a layout that is predefined in the preview and contains styles hardcoded to match the JSON data source being used. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <p:ListDataPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:p=\"clr-namespace:Xamarin.Forms.Pages;assembly=Xamarin.Forms.Pages\" x:Class=\"DataPagesDemo.SessionDataPage\" Title=\"Sessions\" StyleClass=\"Events\"> <p:ListDataPage.DataSource> <p:JsonDataSource Source=\"http://demo3143189.mockable.io/sessions\" /> </p:ListDataPage.DataSource> </p:ListDataPage> JSON data [ { \"end\": \"2016-04-27T18:00:00Z\", \"start\": \"2016-04-27T17:15:00Z\", \"abstract\": \"The new Apple TV has been released, and YOU can be one of the first developers to write apps for it. To make things even better, you can build these apps in C#! This session will introduce the basics of how to create a tvOS app with Xamarin, including: differences between tvOS and iOS APIs, TV user interface best practices, responding to user input, as well as the capabilities and limitations of building apps for a television. Grab some popcorn\u2014this is going to be good!\", \"title\": \"As Seen On TV \u2026 Bringing C# to the Living Room\", \"presenter\": \"Matthew Soucoup\", \"biography\": \"Matthew is a Xamarin MVP and Certified Xamarin Developer from Madison, WI. He founded his company Code Mill Technologies and started the Madison Mobile .Net Developers Group. Matt regularly speaks on .Net and Xamarin development at user groups, code camps and conferences throughout the Midwest. Matt gardens hot peppers, rides bikes, and loves Wisconsin micro-brews and cheese.\", \"image\": \"http://i.imgur.com/ASj60DP.jpg\", \"avatar\": \"http://i.imgur.com/ASj60DP.jpg\", \"room\": \"Crick\" } ] Run! This works because the pre-built style \"Events\" exists in the Light Theme Nuget package and has styles defined that match the data source.(eg. \"title\", \"image\", \"presenter\"). The \"Events\" StyleClass is built to display the ListDataPage control with a custom CardView control that is defined in Xamarin.Forms.Pages. The CardView control has three properties: ImageSource , Text , Detail . The theme is hardcoded to bind the datasource's three fields(from the JSON file) to these properties for display. Customize The inherite style can be overrideden by specifying a template and using data source bindings. The Xaml below declares a custom template for each row using the new ListItemControl and {p:DataSourceBinding} syntax which is includeed in the Xamarin.Forms.Pages Nuget: <p:ListDataPage.DefaultItemTemplate> <DataTemplate> <ViewCell> <p:ListItemControl Title=\"{p:DataSourceBinding title}\" Detail=\"{p:DataSourceBinding room}\" ImageSource=\"{p:DataSourceBinding image}\" DataSource=\"{Binding Value}\" HeightRequest=\"90\" > </p:ListItemControl> </ViewCell> </DataTemplate> </p:ListDataPage.DefaultItemTemplate> By providing a DataTemplate this code overrides the StyleClass and instead uses the default layout for a ListItemControl . Developers that prefer C# to XAML can create data source bindings too (remember to include a using Xamarin.Form.Pages; statement) SetBinding (TitleProperty, new DataSourceBinding (\"title\")); More information at here .","title":"Data Pages"},{"location":"knowledge/mobile-development/xamarin/data-pages/#data-pages","text":"","title":"Data Pages"},{"location":"knowledge/mobile-development/xamarin/data-pages/#get-started","text":"To get started building a simplw data-driven page using the DataPages Preview, follow the steps below. This demo uses a hardcoded style (\"Events\") in the Preview builds that only works with the specific JSON format in the code. Add Nuget Packages Add these Nuget packages to your Xamarin.Forms .NET Standard library and application projects: Xamarin.Forms.Pages Xamarin.Forms.Theme.Base A theme implementation Nuget(eg. Xamarin.Forms.Themes.Light) Add Theme Reference In the App.xaml file, add a custom xmlns:mytheme for the theme and ensure the theme is merged into the application's resource dictionary: <Application xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:mytheme=\"clr-namespace:Xamarin.Forms.Themes;assembly=Xamarin.Forms.Theme.Light\" x:Class=\"DataPagesDemo.App\"> <Application.Resources> <ResourceDictionary MergedWith=\"mytheme:LightThemeResources\" /> </Application.Resources> </Application> Add a XAML Page Add a new XAML page to the Xamarin.Forms application, and change the base class form ContentPage to Xamarin.Forms.Pages.ListDataPage. This has to be done in both the C# and the XAML C# file public partial class SessionDataPage : Xamarin.Forms.Pages.ListDataPage // was ContentPage { public SessionDataPage () { InitializeComponent (); } } Add the DataSource Delete the Content element and replace it with a p:ListDataPage.DataSource to populate the page with data. In the example below a remote Json data file is being loaded from a URL. Note : the preview requires a StyleClass attribute to provide rendering hints for the data source. The StyleClass=\"Events\" refers to a layout that is predefined in the preview and contains styles hardcoded to match the JSON data source being used. <?xml version=\"1.0\" encoding=\"UTF-8\"?> <p:ListDataPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:p=\"clr-namespace:Xamarin.Forms.Pages;assembly=Xamarin.Forms.Pages\" x:Class=\"DataPagesDemo.SessionDataPage\" Title=\"Sessions\" StyleClass=\"Events\"> <p:ListDataPage.DataSource> <p:JsonDataSource Source=\"http://demo3143189.mockable.io/sessions\" /> </p:ListDataPage.DataSource> </p:ListDataPage> JSON data [ { \"end\": \"2016-04-27T18:00:00Z\", \"start\": \"2016-04-27T17:15:00Z\", \"abstract\": \"The new Apple TV has been released, and YOU can be one of the first developers to write apps for it. To make things even better, you can build these apps in C#! This session will introduce the basics of how to create a tvOS app with Xamarin, including: differences between tvOS and iOS APIs, TV user interface best practices, responding to user input, as well as the capabilities and limitations of building apps for a television. Grab some popcorn\u2014this is going to be good!\", \"title\": \"As Seen On TV \u2026 Bringing C# to the Living Room\", \"presenter\": \"Matthew Soucoup\", \"biography\": \"Matthew is a Xamarin MVP and Certified Xamarin Developer from Madison, WI. He founded his company Code Mill Technologies and started the Madison Mobile .Net Developers Group. Matt regularly speaks on .Net and Xamarin development at user groups, code camps and conferences throughout the Midwest. Matt gardens hot peppers, rides bikes, and loves Wisconsin micro-brews and cheese.\", \"image\": \"http://i.imgur.com/ASj60DP.jpg\", \"avatar\": \"http://i.imgur.com/ASj60DP.jpg\", \"room\": \"Crick\" } ] Run! This works because the pre-built style \"Events\" exists in the Light Theme Nuget package and has styles defined that match the data source.(eg. \"title\", \"image\", \"presenter\"). The \"Events\" StyleClass is built to display the ListDataPage control with a custom CardView control that is defined in Xamarin.Forms.Pages. The CardView control has three properties: ImageSource , Text , Detail . The theme is hardcoded to bind the datasource's three fields(from the JSON file) to these properties for display. Customize The inherite style can be overrideden by specifying a template and using data source bindings. The Xaml below declares a custom template for each row using the new ListItemControl and {p:DataSourceBinding} syntax which is includeed in the Xamarin.Forms.Pages Nuget: <p:ListDataPage.DefaultItemTemplate> <DataTemplate> <ViewCell> <p:ListItemControl Title=\"{p:DataSourceBinding title}\" Detail=\"{p:DataSourceBinding room}\" ImageSource=\"{p:DataSourceBinding image}\" DataSource=\"{Binding Value}\" HeightRequest=\"90\" > </p:ListItemControl> </ViewCell> </DataTemplate> </p:ListDataPage.DefaultItemTemplate> By providing a DataTemplate this code overrides the StyleClass and instead uses the default layout for a ListItemControl . Developers that prefer C# to XAML can create data source bindings too (remember to include a using Xamarin.Form.Pages; statement) SetBinding (TitleProperty, new DataSourceBinding (\"title\")); More information at here .","title":"Get Started"},{"location":"knowledge/mobile-development/xamarin/triggers/","text":"Xamarin.Forms Trigger Triggers allow yu to express actionsn declaratively in XAML that change the appearance of controls based on events or property changes. You can assign a trigger directly to a control, or add it to a page-level or app-level resource dictionary to be appied to multiple controls. There are four types of trigger: Xamarin.Forms Trigger Property Triggers Applying a Trigger using a Style Data Triggers Event Triggers Multi Triggers Building a \"require all\" multi trigger EnterActions and ExitActions Property Triggers A simple trigger can be expresses purely in XAML, adding a Trigger element to control's trigger collection. This example shows a trigger that changes an Entry background color whenit receives forcus: <Entry Placeholder=\"enter name\"> <Entry.Triggers> <Trigger TargetType=\"Entry\" Property=\"IsFocused\" Value=\"True\"> <Setter Property=\"BackgroundColor\" Value=\"Yellow\" /> </Trigger> </Entry.Triggers> </Entry> The import parts of the trigger's declaration are: TargetType - the control type that th trigger applies to. Property - the property on the control that is monitored. Value - the value, when it occurs for the monitored property, that causes the trigger to activate. Setter - a collection of Setter elements cab be added and when the trigger condition is met. You must specify the Property and Value to set. ExterActions and ExitAction (not shown) - are written in code and can be used addition to (or instead of) Setter elements. They are described blow . Applying a Trigger using a Style Triggers can also be added to a Style declaration on a control, in a page, pr an applocation ResourceDictionary . This example declares an implicit style (ie. no Key is set) which means it will apply to all Entry controls on the page. <ContentPage.Resources> <ResourceDictionary> <Style TargetType=\"Entry\"> <Style.Triggers> <Trigger TargetType=\"Entry\" Property=\"IsFocused\" Value=\"True\"> <Setter Property=\"BackgroundColor\" Value=\"Yellow\" /> </Trigger> </Style.Triggers> </Style> </ResourceDictionary> </ContentPage.Resources> Data Triggers Data triggers use data binding to monitor another to cause the Setters to get called. Instead of the Property attribute in property trigger, set the Binding attribute to monitoe for the specified value. The example below uses the data binding syntax {Binding Source={x:Reference entry}, Path=Text.length} which is how we refer to another control's properties. When the length of the entry is zero, the trigger is activated. In this sample the trigger disables the button whrn the input is empty. <!-- the x:Name is referenced below in DataTrigger--> <!-- tip: make sure to set the Text=\"\" (or some other default) --> <Entry x:Name=\"entry\" Text=\"\" Placeholder=\"required field\" /> <Button x:Name=\"button\" Text=\"Save\" FontSize=\"Large\" HorizontalOptions=\"Center\"> <Button.Triggers> <DataTrigger TargetType=\"Button\" Binding=\"{Binding Source={x:Reference entry}, Path=Text.Length}\" Value=\"0\"> <Setter Property=\"IsEnabled\" Value=\"False\" /> </DataTrigger> </Button.Triggers> </Button> Tip: when avaluating Path=Text.Lenth always provide a default value for the target property (eg. Text=\"\" because otherwise it will be null and the trigger won't work like you expect.) In addition to specifying Setter s you can also provide EnterActions and ExitActions Event Triggers The EventTrigger element requires only an Entry property, such as \"Clicked\" ing the example below. <EventTrigger Event=\"Clicked\"> <local:NumericValidationTriggerAction /> </EventTrigger> Notice that there no Setter elements but rather a reference to a class defined by local:NumbericValidationTriggerAction which requires the xmlns:local to be declared in the page's XAML: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:WorkingWithTriggers;assembly=WorkingWithTriggers\" The class itself implements TriggerAction which means it should provide an override for the Invoke method that is called whenver the trigger event occurs. a Trigger action implementation should: Implement the generic TriggerAction<T> class, with the generic parameter corresponding with the type of control the trigger will be applied to. You can use supperclasses such as VisualElement to write trigger actions that work with a variety of controls, or specify a control type like Entry . Override the Invoke method - this is called whenever the trigger criteria are met. Optionally expose properties that can be set in the XAML when the trigger is declared (such as Anchor , Scale , and Length in this example). public class NumericValidationTriggerAction : TriggerAction<Entry> { protected override void Invoke (Entry entry) { double result; bool isValid = Double.TryParse (entry.Text, out result); entry.TextColor = isValid ? Color.Default : Color.Red; } } The properties exposed by the trigger action can be set in the XAML declaration as follows: <EventTrigger Event=\"TextChanged\"> <local:NumericValidationTriggerAction /> </EventTrigger> Be careful whrn sharing triggers in a ResourceDictionay , one instance will be shared among controls so any state that is configured once will apply to them all. Note that event triggers do not support Enteractions and ExitActions decribed below . Multi Triggers A MultiTrigger looks similar to a Trigger or DataTrigger except there can be more than one condition. All the conditions must be true before the Setter s are trigged. Here's an example of a trigger for a button that binds to two different inputs ( email and phone ): <MultiTrigger TargetType=\"Button\"> <MultiTrigger.Conditions> <BindingCondition Binding=\"{Binding Source={x:Reference email}, Path=Text.Length}\" Value=\"0\" /> <BindingCondition Binding=\"{Binding Source={x:Reference phone}, Path=Text.Length}\" Value=\"0\" /> </MultiTrigger.Conditions> <Setter Property=\"IsEnabled\" Value=\"False\" /> <!-- multiple Setter elements are allowed --> </MultiTrigger> The Conditions collection could also contain PropertyCondition elements like this: <PropertyCondition Property=\"Text\" Value=\"OK\" /> Building a \"require all\" multi trigger The multi trigger only updates its control when all conditions are true. Testing for \"all field lengths are zero\" (such as a login page where all inputs must be complete) is tricky because you want a condition \"where Text.Length >0 \" but this can't be expressed in XAML. This can be done with an IValueConverter . The converter code below trnsforms the Text.Length binding into a bool that indicates whether a field is empty or not: public class MultiTriggerConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if ((int)value > 0) // length > 0 ? return true; // some data has been entered else return false; // input is empty } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotSupportedException (); } } To use this converter in a multi trigger, first add it to the page's resource dictionary (along with a custom xmls:local namespace definition): <ResourceDictionary> <local:MultiTriggerConverter x:Key=\"dataHasBeenEntered\" /> </ResourceDictionary> The XAML is shown below. Note the following differences from the first multi trigger example: The button has IsEnable=\"false\" set by default. The multi trigger conditions use the converter to turn the Text.Length value into a booleam . When all the conditions are true , the setter makes the button's IsEnabeld property true . <Entry x:Name=\"user\" Text=\"\" Placeholder=\"user name\" /> <Entry x:Name=\"pwd\" Text=\"\" Placeholder=\"password\" /> <Button x:Name=\"loginButton\" Text=\"Login\" FontSize=\"Large\" HorizontalOptions=\"Center\" IsEnabled=\"false\"> <Button.Triggers> <MultiTrigger TargetType=\"Button\"> <MultiTrigger.Conditions> <BindingCondition Binding=\"{Binding Source={x:Reference user}, Path=Text.Length, Converter={StaticResource dataHasBeenEntered}}\" Value=\"true\" /> <BindingCondition Binding=\"{Binding Source={x:Reference pwd}, Path=Text.Length, Converter={StaticResource dataHasBeenEntered}}\" Value=\"true\" /> </MultiTrigger.Conditions> <Setter Property=\"IsEnabled\" Value=\"True\" /> </MultiTrigger> </Button.Triggers> </Button> These screenshots show the difference between the two multi trigger examples above. In the top part of the creens, text input in just one Entry is enough to enable the S.ave button. In the bottom part of the screens, the Login button remains inactive until both fields contain data. EnterActions and ExitActions Another way to implement changes when a trigger occurs is by adding EnterActions and ExitActions collections and specifying TriggerAction<T> implementations. You can provide both EnterActions and ExitActions as well as Setter s in a trigger, but be aware that the Setter are called immediately (they do not wait for the EnterAction or ExitAction to complete). Alternatively you can perform everything in the code and not use Setter s at all. <Entry Placeholder=\"enter job title\"> <Entry.Triggers> <Trigger TargetType=\"Entry\" Property=\"Entry.IsFocused\" Value=\"True\"> <Trigger.EnterActions> <local:FadeTriggerAction StartsFrom=\"0\"\" /> </Trigger.EnterActions> <Trigger.ExitActions> <local:FadeTriggerAction StartsFrom=\"1\" /> </Trigger.ExitActions> <!-- You can use both Enter/Exit and Setter together if required --> </Trigger> </Entry.Triggers> </Entry> As alaws, when a class is referenced in XAML you should declare a namespace such as xmlns:local as shown here: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:WorkingWithTriggers;assembly=WorkingWithTriggers\" The FadetriggerAction code is shown below: public class FadeTriggerAction : TriggerAction<VisualElement> { public FadeTriggerAction() {} public int StartsFrom { set; get; } protected override void Invoke (VisualElement visual) { visual.Animate(\"\", new Animation( (d)=>{ var val = StartsFrom==1 ? d : 1-d; visual.BackgroundColor = Color.FromRgb(1, val, 1); }), length:1000, // milliseconds easing: Easing.Linear); } } Note: EnterActions and ExitActions are ignored on Envent Triggers . Get more information at here","title":"Triggers"},{"location":"knowledge/mobile-development/xamarin/triggers/#xamarinforms-trigger","text":"Triggers allow yu to express actionsn declaratively in XAML that change the appearance of controls based on events or property changes. You can assign a trigger directly to a control, or add it to a page-level or app-level resource dictionary to be appied to multiple controls. There are four types of trigger: Xamarin.Forms Trigger Property Triggers Applying a Trigger using a Style Data Triggers Event Triggers Multi Triggers Building a \"require all\" multi trigger EnterActions and ExitActions","title":"Xamarin.Forms Trigger"},{"location":"knowledge/mobile-development/xamarin/triggers/#property-triggers","text":"A simple trigger can be expresses purely in XAML, adding a Trigger element to control's trigger collection. This example shows a trigger that changes an Entry background color whenit receives forcus: <Entry Placeholder=\"enter name\"> <Entry.Triggers> <Trigger TargetType=\"Entry\" Property=\"IsFocused\" Value=\"True\"> <Setter Property=\"BackgroundColor\" Value=\"Yellow\" /> </Trigger> </Entry.Triggers> </Entry> The import parts of the trigger's declaration are: TargetType - the control type that th trigger applies to. Property - the property on the control that is monitored. Value - the value, when it occurs for the monitored property, that causes the trigger to activate. Setter - a collection of Setter elements cab be added and when the trigger condition is met. You must specify the Property and Value to set. ExterActions and ExitAction (not shown) - are written in code and can be used addition to (or instead of) Setter elements. They are described blow .","title":"Property Triggers"},{"location":"knowledge/mobile-development/xamarin/triggers/#applying-a-trigger-using-a-style","text":"Triggers can also be added to a Style declaration on a control, in a page, pr an applocation ResourceDictionary . This example declares an implicit style (ie. no Key is set) which means it will apply to all Entry controls on the page. <ContentPage.Resources> <ResourceDictionary> <Style TargetType=\"Entry\"> <Style.Triggers> <Trigger TargetType=\"Entry\" Property=\"IsFocused\" Value=\"True\"> <Setter Property=\"BackgroundColor\" Value=\"Yellow\" /> </Trigger> </Style.Triggers> </Style> </ResourceDictionary> </ContentPage.Resources>","title":"Applying a Trigger using a Style"},{"location":"knowledge/mobile-development/xamarin/triggers/#data-triggers","text":"Data triggers use data binding to monitor another to cause the Setters to get called. Instead of the Property attribute in property trigger, set the Binding attribute to monitoe for the specified value. The example below uses the data binding syntax {Binding Source={x:Reference entry}, Path=Text.length} which is how we refer to another control's properties. When the length of the entry is zero, the trigger is activated. In this sample the trigger disables the button whrn the input is empty. <!-- the x:Name is referenced below in DataTrigger--> <!-- tip: make sure to set the Text=\"\" (or some other default) --> <Entry x:Name=\"entry\" Text=\"\" Placeholder=\"required field\" /> <Button x:Name=\"button\" Text=\"Save\" FontSize=\"Large\" HorizontalOptions=\"Center\"> <Button.Triggers> <DataTrigger TargetType=\"Button\" Binding=\"{Binding Source={x:Reference entry}, Path=Text.Length}\" Value=\"0\"> <Setter Property=\"IsEnabled\" Value=\"False\" /> </DataTrigger> </Button.Triggers> </Button> Tip: when avaluating Path=Text.Lenth always provide a default value for the target property (eg. Text=\"\" because otherwise it will be null and the trigger won't work like you expect.) In addition to specifying Setter s you can also provide EnterActions and ExitActions","title":"Data Triggers"},{"location":"knowledge/mobile-development/xamarin/triggers/#event-triggers","text":"The EventTrigger element requires only an Entry property, such as \"Clicked\" ing the example below. <EventTrigger Event=\"Clicked\"> <local:NumericValidationTriggerAction /> </EventTrigger> Notice that there no Setter elements but rather a reference to a class defined by local:NumbericValidationTriggerAction which requires the xmlns:local to be declared in the page's XAML: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:WorkingWithTriggers;assembly=WorkingWithTriggers\" The class itself implements TriggerAction which means it should provide an override for the Invoke method that is called whenver the trigger event occurs. a Trigger action implementation should: Implement the generic TriggerAction<T> class, with the generic parameter corresponding with the type of control the trigger will be applied to. You can use supperclasses such as VisualElement to write trigger actions that work with a variety of controls, or specify a control type like Entry . Override the Invoke method - this is called whenever the trigger criteria are met. Optionally expose properties that can be set in the XAML when the trigger is declared (such as Anchor , Scale , and Length in this example). public class NumericValidationTriggerAction : TriggerAction<Entry> { protected override void Invoke (Entry entry) { double result; bool isValid = Double.TryParse (entry.Text, out result); entry.TextColor = isValid ? Color.Default : Color.Red; } } The properties exposed by the trigger action can be set in the XAML declaration as follows: <EventTrigger Event=\"TextChanged\"> <local:NumericValidationTriggerAction /> </EventTrigger> Be careful whrn sharing triggers in a ResourceDictionay , one instance will be shared among controls so any state that is configured once will apply to them all. Note that event triggers do not support Enteractions and ExitActions decribed below .","title":"Event Triggers"},{"location":"knowledge/mobile-development/xamarin/triggers/#multi-triggers","text":"A MultiTrigger looks similar to a Trigger or DataTrigger except there can be more than one condition. All the conditions must be true before the Setter s are trigged. Here's an example of a trigger for a button that binds to two different inputs ( email and phone ): <MultiTrigger TargetType=\"Button\"> <MultiTrigger.Conditions> <BindingCondition Binding=\"{Binding Source={x:Reference email}, Path=Text.Length}\" Value=\"0\" /> <BindingCondition Binding=\"{Binding Source={x:Reference phone}, Path=Text.Length}\" Value=\"0\" /> </MultiTrigger.Conditions> <Setter Property=\"IsEnabled\" Value=\"False\" /> <!-- multiple Setter elements are allowed --> </MultiTrigger> The Conditions collection could also contain PropertyCondition elements like this: <PropertyCondition Property=\"Text\" Value=\"OK\" />","title":"Multi Triggers"},{"location":"knowledge/mobile-development/xamarin/triggers/#building-a-require-all-multi-trigger","text":"The multi trigger only updates its control when all conditions are true. Testing for \"all field lengths are zero\" (such as a login page where all inputs must be complete) is tricky because you want a condition \"where Text.Length >0 \" but this can't be expressed in XAML. This can be done with an IValueConverter . The converter code below trnsforms the Text.Length binding into a bool that indicates whether a field is empty or not: public class MultiTriggerConverter : IValueConverter { public object Convert(object value, Type targetType, object parameter, CultureInfo culture) { if ((int)value > 0) // length > 0 ? return true; // some data has been entered else return false; // input is empty } public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) { throw new NotSupportedException (); } } To use this converter in a multi trigger, first add it to the page's resource dictionary (along with a custom xmls:local namespace definition): <ResourceDictionary> <local:MultiTriggerConverter x:Key=\"dataHasBeenEntered\" /> </ResourceDictionary> The XAML is shown below. Note the following differences from the first multi trigger example: The button has IsEnable=\"false\" set by default. The multi trigger conditions use the converter to turn the Text.Length value into a booleam . When all the conditions are true , the setter makes the button's IsEnabeld property true . <Entry x:Name=\"user\" Text=\"\" Placeholder=\"user name\" /> <Entry x:Name=\"pwd\" Text=\"\" Placeholder=\"password\" /> <Button x:Name=\"loginButton\" Text=\"Login\" FontSize=\"Large\" HorizontalOptions=\"Center\" IsEnabled=\"false\"> <Button.Triggers> <MultiTrigger TargetType=\"Button\"> <MultiTrigger.Conditions> <BindingCondition Binding=\"{Binding Source={x:Reference user}, Path=Text.Length, Converter={StaticResource dataHasBeenEntered}}\" Value=\"true\" /> <BindingCondition Binding=\"{Binding Source={x:Reference pwd}, Path=Text.Length, Converter={StaticResource dataHasBeenEntered}}\" Value=\"true\" /> </MultiTrigger.Conditions> <Setter Property=\"IsEnabled\" Value=\"True\" /> </MultiTrigger> </Button.Triggers> </Button> These screenshots show the difference between the two multi trigger examples above. In the top part of the creens, text input in just one Entry is enough to enable the S.ave button. In the bottom part of the screens, the Login button remains inactive until both fields contain data.","title":"Building a \"require all\" multi trigger"},{"location":"knowledge/mobile-development/xamarin/triggers/#enteractions-and-exitactions","text":"Another way to implement changes when a trigger occurs is by adding EnterActions and ExitActions collections and specifying TriggerAction<T> implementations. You can provide both EnterActions and ExitActions as well as Setter s in a trigger, but be aware that the Setter are called immediately (they do not wait for the EnterAction or ExitAction to complete). Alternatively you can perform everything in the code and not use Setter s at all. <Entry Placeholder=\"enter job title\"> <Entry.Triggers> <Trigger TargetType=\"Entry\" Property=\"Entry.IsFocused\" Value=\"True\"> <Trigger.EnterActions> <local:FadeTriggerAction StartsFrom=\"0\"\" /> </Trigger.EnterActions> <Trigger.ExitActions> <local:FadeTriggerAction StartsFrom=\"1\" /> </Trigger.ExitActions> <!-- You can use both Enter/Exit and Setter together if required --> </Trigger> </Entry.Triggers> </Entry> As alaws, when a class is referenced in XAML you should declare a namespace such as xmlns:local as shown here: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:WorkingWithTriggers;assembly=WorkingWithTriggers\" The FadetriggerAction code is shown below: public class FadeTriggerAction : TriggerAction<VisualElement> { public FadeTriggerAction() {} public int StartsFrom { set; get; } protected override void Invoke (VisualElement visual) { visual.Animate(\"\", new Animation( (d)=>{ var val = StartsFrom==1 ? d : 1-d; visual.BackgroundColor = Color.FromRgb(1, val, 1); }), length:1000, // milliseconds easing: Easing.Linear); } } Note: EnterActions and ExitActions are ignored on Envent Triggers . Get more information at here","title":"EnterActions and ExitActions"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/","text":"Xamarin.Forms Themes StyleClass The StypeClass property allows a view's appearance to be changed according to a definition provided by a theme. The Light and Dark themes both define three different appearances for a BoxView: horizontalRul, Circel, and Rounded. This markup show three different BoxViews with different style classes applied: <StackLayout Padding=\"40\"> <BoxView StyleClass=\"HorizontalRule\" /> <BoxView StyleClass=\"Circle\" /> <BoxView StyleClass=\"Rounded\" /> </StackLayout> Built-in Classes In addition to automatically styling the common controls the light and dark themes currently support the following classes that can be applied by setting the StyleClass on these controls. BoxView HorizontalRule Circle Rounded Image Circle Rounded Thumbnail Button Default Primary Success Info Warning Danger Link Small Large Label Header Subheader Body Link Inverse Troubleshooting Could not load file or assembly 'Xamarin.Form.Theme.Light' or one of it;s dependencies In the preview release, themes may not be able to load at runtime. Add the code shown below into the relevant project to fix this error. iOS In the AppDelegate.cs add the following lines after LoadApplication var x = typeof(Xamarin.Forms.Themes.DarkThemeResources); x = typeof(Xamarin.Forms.Themes.LightThemeResources); x = typeof(Xamarin.Forms.Themes.iOS.UnderlineEffect); Android In the MainActivity.cs add the following lines after LoadApplication var x = typeof(Xamarin.Forms.Themes.DarkThemeResources); x = typeof(Xamarin.Forms.Themes.LightThemeResources); x = typeof(Xamarin.Forms.Themes.Android.UnderlineEffect); Xamarin.Forms Light Theme Add Nuget packages Xamarin.Forms.Theme.Base Xamarin.Forms.Theme.Light Add to the Resource Dictionary In the App.xaml file add a new custom xmlns for the theme, and then ensure the theme's resources are merged with the application's resource dictionary. An example XAML file is shown below: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Application xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"EvolveApp.App\" xmlns:light=\"clr-namespace:Xamarin.Forms.Themes;assembly=Xamarin.Forms.Theme.Light\"> <Application.Resources> <ResourceDictionary MergedWith=\"light:LightThemeResources\" /> </Application.Resources> </Application> Load theme classes Follow troubleshooting step. Use StyleClass <StackLayout Padding=\"20\"> <Button Text=\"Button Default\" /> <Button Text=\"Button Class Default\" StyleClass=\"Default\" /> <Button Text=\"Button Class Primary\" StyleClass=\"Primary\" /> <Button Text=\"Button Class Success\" StyleClass=\"Success\" /> <Button Text=\"Button Class Info\" StyleClass=\"Info\" /> <Button Text=\"Button Class Warning\" StyleClass=\"Warning\" /> <Button Text=\"Button Class Danger\" StyleClass=\"Danger\" /> <Button Text=\"Button Class Link\" StyleClass=\"Link\" /> <Button Text=\"Button Class Default Small\" StyleClass=\"Small\" /> <Button Text=\"Button Class Default Large\" StyleClass=\"Large\" /> </StackLayout> Creating a Custom Xamarin.Forms Theme Note the Class attribute for Style (as opposed to the x:Key attribute available in earlier version of Xamarin.Forms) <ResourceDictionary> <!-- DEFINE ANY CONSTANTS --> <Color x:Key=\"SeparatorLineColor\">#CCCCCC</Color> <Color x:Key=\"iOSDefaultTintColor\">#007aff</Color> <Color x:Key=\"AndroidDefaultAccentColorColor\">#1FAECE</Color> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"AccentColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSDefaultTintColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidDefaultAccentColorColor}\" /> </OnPlatform> <!-- BOXVIEW CLASSES --> <Style TargetType=\"BoxView\" Class=\"HorizontalRule\"> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource SeparatorLineColor }\" /> <Setter Property=\"HeightRequest\" Value=\"1\" /> </Style> <Style TargetType=\"BoxView\" Class=\"Circle\"> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource AccentColor }\" /> <Setter Property=\"WidthRequest\" Value=\"34\"/> <Setter Property=\"HeightRequest\" Value=\"34\"/> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"local:ThemeEffects.Circle\" Value=\"True\" /> </Style> <Style TargetType=\"BoxView\" Class=\"Rounded\"> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource AccentColor }\" /> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource AccentColor }\" /> <Setter Property=\"local:ThemeEffects.CornerRadius\" Value=\"4\" /> </Style> </ResourceDictionary> You'll notice that the Rounded class refers to a custom effext CornerRadius. The code for this effect is given below - to reference it correctly a custom xmlns must be added to the App.xaml's root element: xmlns:local=\"clr-namespace:ThemesDemo;assembly=ThemesDemo\" C# code in the .NET Standard library project or Shared Project The code for creating a round-corner BoxView use effects. The corner radius is applied using a BindableProperty and is implemented by applying an effect. The effect requires platform-specific code in the iOS and Android projects(shown below). namespace ThemesDemo { public static class ThemeEffects { public static readonly BindableProperty CornerRadiusProperty = BindableProperty.CreateAttached(\"CornerRadius\", typeof(double), typeof(ThemeEffects), 0.0, propertyChanged: OnChanged<CornerRadiusEffect, double>); private static void OnChanged<TEffect, TProp>(BindableObject bindable, object oldValue, object newValue) where TEffect : Effect, new() { if (!(bindable is View view)) { return; } if (EqualityComparer<TProp>.Equals(newValue, default(TProp))) { var toRemove = view.Effects.FirstOrDefault(e => e is TEffect); if (toRemove != null) { view.Effects.Remove(toRemove); } } else { view.Effects.Add(new TEffect()); } } public static void SetCornerRadius(BindableObject view, double radius) { view.SetValue(CornerRadiusProperty, radius); } public static double GetCornerRadius(BindableObject view) { return (double)view.GetValue(CornerRadiusProperty); } private class CornerRadiusEffect : RoutingEffect { public CornerRadiusEffect() : base(\"Xamarin.CornerRadiusEffect\") { } } } } C# code in the iOS project using System; using Xamarin.Forms; using Xamarin.Forms.Platform.iOS; using CoreGraphics; using Foundation; using XFThemes; namespace ThemesDemo.iOS { public class CornerRadiusEffect : PlatformEffect { private nfloat _originalRadius; protected override void OnAttached() { if (Container != null) { _originalRadius = Container.Layer.CornerRadius; Container.ClipsToBounds = true; UpdateCorner(); } } protected override void OnDetached() { if (Container != null) { Container.Layer.CornerRadius = _originalRadius; Container.ClipsToBounds = false; } } protected override void OnElementPropertyChanged(System.ComponentModel.PropertyChangedEventArgs args) { base.OnElementPropertyChanged(args); if (args.PropertyName == ThemeEffects.CornerRadiusProperty.PropertyName) { UpdateCorner(); } } private void UpdateCorner() { Container.Layer.CornerRadius = (nfloat)ThemeEffects.GetCornerRadius(Element); } } } C# code in the Android project using System; using Xamarin.Forms.Platform; using Xamarin.Forms.Platform.Android; using Android.Views; using Android.Graphics; namespace ThemesDemo.Droid { public class CornerRadiusEffect : BaseEffect { private ViewOutlineProvider _originalProvider; protected override bool CanBeApplied() { return Container != null && Android.OS.Build.VERSION.SdkInt >= Android.OS.BuildVersionCodes.Lollipop; } protected override void OnAttachedInternal() { _originalProvider = Container.OutlineProvider; Container.OutlineProvider = new CornerRadiusOutlineProvider(Element); Container.ClipToOutline = true; } protected override void OnDetachedInternal() { Container.OutlineProvider = _originalProvider; Container.ClipToOutline = false; } protected override void OnElementPropertyChanged(System.ComponentModel.PropertyChangedEventArgs args) { base.OnElementPropertyChanged(args); if (!Attached) { return; } if (args.PropertyName == ThemeEffects.CornerRadiusProperty.PropertyName) { Container.Invalidate(); } } private class CornerRadiusOutlineProvider : ViewOutlineProvider { private Xamarin.Forms.Element _element; public CornerRadiusOutlineProvider(Xamarin.Forms.Element element) { _element = element; } public override void GetOutline(Android.Views.View view, Outline outline) { var pixels = (float)ThemeEffects.GetCornerRadius(_element) * view.Resources.DisplayMetrics.Density; outline.SetRoundRect(new Rect(0, 0, view.Width, view.Height), (int)pixels); } } } } Summary A custom theme can be created by defining styles for each control that requires custom appearance. Multiple styles for a control should be distinguished by different Class attributes in the resource dictionary, and then applied the StyleClass attribute on the control. Get more information at here .","title":"Themes"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#xamarinforms-themes","text":"","title":"Xamarin.Forms Themes"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#styleclass","text":"The StypeClass property allows a view's appearance to be changed according to a definition provided by a theme. The Light and Dark themes both define three different appearances for a BoxView: horizontalRul, Circel, and Rounded. This markup show three different BoxViews with different style classes applied: <StackLayout Padding=\"40\"> <BoxView StyleClass=\"HorizontalRule\" /> <BoxView StyleClass=\"Circle\" /> <BoxView StyleClass=\"Rounded\" /> </StackLayout>","title":"StyleClass"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#built-in-classes","text":"In addition to automatically styling the common controls the light and dark themes currently support the following classes that can be applied by setting the StyleClass on these controls.","title":"Built-in Classes"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#boxview","text":"HorizontalRule Circle Rounded","title":"BoxView"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#image","text":"Circle Rounded Thumbnail","title":"Image"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#button","text":"Default Primary Success Info Warning Danger Link Small Large","title":"Button"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#label","text":"Header Subheader Body Link Inverse","title":"Label"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#troubleshooting","text":"Could not load file or assembly 'Xamarin.Form.Theme.Light' or one of it;s dependencies In the preview release, themes may not be able to load at runtime. Add the code shown below into the relevant project to fix this error. iOS In the AppDelegate.cs add the following lines after LoadApplication var x = typeof(Xamarin.Forms.Themes.DarkThemeResources); x = typeof(Xamarin.Forms.Themes.LightThemeResources); x = typeof(Xamarin.Forms.Themes.iOS.UnderlineEffect); Android In the MainActivity.cs add the following lines after LoadApplication var x = typeof(Xamarin.Forms.Themes.DarkThemeResources); x = typeof(Xamarin.Forms.Themes.LightThemeResources); x = typeof(Xamarin.Forms.Themes.Android.UnderlineEffect);","title":"Troubleshooting"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#xamarinforms-light-theme","text":"Add Nuget packages Xamarin.Forms.Theme.Base Xamarin.Forms.Theme.Light Add to the Resource Dictionary In the App.xaml file add a new custom xmlns for the theme, and then ensure the theme's resources are merged with the application's resource dictionary. An example XAML file is shown below: <?xml version=\"1.0\" encoding=\"utf-8\"?> <Application xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"EvolveApp.App\" xmlns:light=\"clr-namespace:Xamarin.Forms.Themes;assembly=Xamarin.Forms.Theme.Light\"> <Application.Resources> <ResourceDictionary MergedWith=\"light:LightThemeResources\" /> </Application.Resources> </Application> Load theme classes Follow troubleshooting step. Use StyleClass <StackLayout Padding=\"20\"> <Button Text=\"Button Default\" /> <Button Text=\"Button Class Default\" StyleClass=\"Default\" /> <Button Text=\"Button Class Primary\" StyleClass=\"Primary\" /> <Button Text=\"Button Class Success\" StyleClass=\"Success\" /> <Button Text=\"Button Class Info\" StyleClass=\"Info\" /> <Button Text=\"Button Class Warning\" StyleClass=\"Warning\" /> <Button Text=\"Button Class Danger\" StyleClass=\"Danger\" /> <Button Text=\"Button Class Link\" StyleClass=\"Link\" /> <Button Text=\"Button Class Default Small\" StyleClass=\"Small\" /> <Button Text=\"Button Class Default Large\" StyleClass=\"Large\" /> </StackLayout>","title":"Xamarin.Forms Light Theme"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#creating-a-custom-xamarinforms-theme","text":"Note the Class attribute for Style (as opposed to the x:Key attribute available in earlier version of Xamarin.Forms) <ResourceDictionary> <!-- DEFINE ANY CONSTANTS --> <Color x:Key=\"SeparatorLineColor\">#CCCCCC</Color> <Color x:Key=\"iOSDefaultTintColor\">#007aff</Color> <Color x:Key=\"AndroidDefaultAccentColorColor\">#1FAECE</Color> <OnPlatform x:TypeArguments=\"Color\" x:Key=\"AccentColor\"> <On Platform=\"iOS\" Value=\"{StaticResource iOSDefaultTintColor}\" /> <On Platform=\"Android\" Value=\"{StaticResource AndroidDefaultAccentColorColor}\" /> </OnPlatform> <!-- BOXVIEW CLASSES --> <Style TargetType=\"BoxView\" Class=\"HorizontalRule\"> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource SeparatorLineColor }\" /> <Setter Property=\"HeightRequest\" Value=\"1\" /> </Style> <Style TargetType=\"BoxView\" Class=\"Circle\"> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource AccentColor }\" /> <Setter Property=\"WidthRequest\" Value=\"34\"/> <Setter Property=\"HeightRequest\" Value=\"34\"/> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"local:ThemeEffects.Circle\" Value=\"True\" /> </Style> <Style TargetType=\"BoxView\" Class=\"Rounded\"> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource AccentColor }\" /> <Setter Property=\"HorizontalOptions\" Value=\"Start\" /> <Setter Property=\"BackgroundColor\" Value=\"{ StaticResource AccentColor }\" /> <Setter Property=\"local:ThemeEffects.CornerRadius\" Value=\"4\" /> </Style> </ResourceDictionary> You'll notice that the Rounded class refers to a custom effext CornerRadius. The code for this effect is given below - to reference it correctly a custom xmlns must be added to the App.xaml's root element: xmlns:local=\"clr-namespace:ThemesDemo;assembly=ThemesDemo\"","title":"Creating a Custom Xamarin.Forms Theme"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#c-code-in-the-net-standard-library-project-or-shared-project","text":"The code for creating a round-corner BoxView use effects. The corner radius is applied using a BindableProperty and is implemented by applying an effect. The effect requires platform-specific code in the iOS and Android projects(shown below). namespace ThemesDemo { public static class ThemeEffects { public static readonly BindableProperty CornerRadiusProperty = BindableProperty.CreateAttached(\"CornerRadius\", typeof(double), typeof(ThemeEffects), 0.0, propertyChanged: OnChanged<CornerRadiusEffect, double>); private static void OnChanged<TEffect, TProp>(BindableObject bindable, object oldValue, object newValue) where TEffect : Effect, new() { if (!(bindable is View view)) { return; } if (EqualityComparer<TProp>.Equals(newValue, default(TProp))) { var toRemove = view.Effects.FirstOrDefault(e => e is TEffect); if (toRemove != null) { view.Effects.Remove(toRemove); } } else { view.Effects.Add(new TEffect()); } } public static void SetCornerRadius(BindableObject view, double radius) { view.SetValue(CornerRadiusProperty, radius); } public static double GetCornerRadius(BindableObject view) { return (double)view.GetValue(CornerRadiusProperty); } private class CornerRadiusEffect : RoutingEffect { public CornerRadiusEffect() : base(\"Xamarin.CornerRadiusEffect\") { } } } }","title":"C# code in the .NET Standard library project or Shared Project"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#c-code-in-the-ios-project","text":"using System; using Xamarin.Forms; using Xamarin.Forms.Platform.iOS; using CoreGraphics; using Foundation; using XFThemes; namespace ThemesDemo.iOS { public class CornerRadiusEffect : PlatformEffect { private nfloat _originalRadius; protected override void OnAttached() { if (Container != null) { _originalRadius = Container.Layer.CornerRadius; Container.ClipsToBounds = true; UpdateCorner(); } } protected override void OnDetached() { if (Container != null) { Container.Layer.CornerRadius = _originalRadius; Container.ClipsToBounds = false; } } protected override void OnElementPropertyChanged(System.ComponentModel.PropertyChangedEventArgs args) { base.OnElementPropertyChanged(args); if (args.PropertyName == ThemeEffects.CornerRadiusProperty.PropertyName) { UpdateCorner(); } } private void UpdateCorner() { Container.Layer.CornerRadius = (nfloat)ThemeEffects.GetCornerRadius(Element); } } }","title":"C# code in the iOS project"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#c-code-in-the-android-project","text":"using System; using Xamarin.Forms.Platform; using Xamarin.Forms.Platform.Android; using Android.Views; using Android.Graphics; namespace ThemesDemo.Droid { public class CornerRadiusEffect : BaseEffect { private ViewOutlineProvider _originalProvider; protected override bool CanBeApplied() { return Container != null && Android.OS.Build.VERSION.SdkInt >= Android.OS.BuildVersionCodes.Lollipop; } protected override void OnAttachedInternal() { _originalProvider = Container.OutlineProvider; Container.OutlineProvider = new CornerRadiusOutlineProvider(Element); Container.ClipToOutline = true; } protected override void OnDetachedInternal() { Container.OutlineProvider = _originalProvider; Container.ClipToOutline = false; } protected override void OnElementPropertyChanged(System.ComponentModel.PropertyChangedEventArgs args) { base.OnElementPropertyChanged(args); if (!Attached) { return; } if (args.PropertyName == ThemeEffects.CornerRadiusProperty.PropertyName) { Container.Invalidate(); } } private class CornerRadiusOutlineProvider : ViewOutlineProvider { private Xamarin.Forms.Element _element; public CornerRadiusOutlineProvider(Xamarin.Forms.Element element) { _element = element; } public override void GetOutline(Android.Views.View view, Outline outline) { var pixels = (float)ThemeEffects.GetCornerRadius(_element) * view.Resources.DisplayMetrics.Density; outline.SetRoundRect(new Rect(0, 0, view.Width, view.Height), (int)pixels); } } } }","title":"C# code in the Android project"},{"location":"knowledge/mobile-development/xamarin/xamarin-forms-theme/#summary","text":"A custom theme can be created by defining styles for each control that requires custom appearance. Multiple styles for a control should be distinguished by different Class attributes in the resource dictionary, and then applied the StyleClass attribute on the control. Get more information at here .","title":"Summary"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/","text":"Xamarin.Forms Control Templates Introduction Xamarin.Forms control templates provide the ability to easily theme and re-theme application pages at runtime. This article provides an introduction to control templates. Controls have different properties, such as BackgroundColor and TextColor , that can define aspects of the control's appearance. These properties can be set using styles , which can be chaned at runtime to implement basic theming. However, styles don't maintain a clean separation between the appearance of a page and its content, and the changes that can be made by setting such properties are limited. Control templates provide a clean separation between the appearance of a page and its content, therefore enabling the creation of pages that can easily be themed. Creating a ControlTemplate Control templates can be defined at the application level or at the page level. This article demonstrates how to create and consume control templates. A ControlTemplate specifies the appearence of a page or view, and contains a root layout, and within the layout, the controls that implement the template. Typically, a ControlTemplate will utilize a ContentPresenter to mark where the content to be displayed bu the page or view will appear. The page or view that consumes the ControlTemplate will then define content to be displayed by the ContentPredenter . The following diageam illustrates a ControlTemplate for a page that contains a number of controls, including a ContentPresenter marked by a blue rectangle: A [ ControlTemplate ] can be applied to the following types by setting their ControlTemplate properties: ContentPage ContentView TemplatedPage TemplatedView When a ControlTemplate is created and assigned to these types, any existing appearance is replaced with the appearance defined in the ControlTemplate . in addtion, as well as setting appearance by using the ControlTemplate property, control templats can also be applied by using styles to further expand theme ability. Control templates can be created in XAML and in C#: Control templates created in XAML are defined in a ResourceDictionary that's assigned to the Resource collection of a page, or more typically to the Resources collection of the application. Control templates created in C# are typically defined in the page's class, or in a class that can be globally accessed. Choosing where to define a ControlTemplate instance impacts where it can be used: ControlTemplate instances defined at the page-level can only be applied to the page. ControlTemplate instances defined at the application-level can be applied to page throughout the application. Creating a ControlTemplate in XAML To define a ControlTemplate at the application level, a ResourceDictionary must be added to the App class. By default, all Xamarin.Forms application created from a template use the App class to implement the Application subclass. To declare a ControlTemplate at the application level, in the application's ResourceDictionary using XAM, the default App class must be replaced with a XAML App class and associated code-behind, as shown in the following code example: <Application xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"SimpleTheme.App\"> <Application.Resources> <ResourceDictionary> <ControlTemplate x:Key=\"TealTemplate\"> <Grid> ... <BoxView ... /> <Label Text=\"Control Template Demo App\" TextColor=\"White\" VerticalOptions=\"Center\" ... /> <ContentPresenter ... /> <BoxView Color=\"Teal\" ... /> <Label Text=\"(c) Xamarin 2016\" TextColor=\"White\" VerticalOptions=\"Center\" ... /> </Grid> </ControlTemplate> <ControlTemplate x:Key=\"AquaTemplate\"> ... </ControlTemplate> </ResourceDictionary> </Application.Resources> </Application> Each ControlTemplate instance is created as a reusable object in a ResourceDictionary . This ia achieved by giving each declaration a unique x:Key attribute, which provides it with a descriptive key in the ResourceDictionary . The following code example shows the associated App code-behind: public partial class App : Application { public App () { InitializeComponent (); MainPage = new HomePage (); } } As well as setting the MainPage property, the code-behind must also call the InitializeComponent method to load and parse the associated XAML. The following code example shows a ContentPage applying the TealTemplate to the ContentView : <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"SimpleTheme.HomePage\"> <ContentView x:Name=\"contentView\" Padding=\"0,20,0,0\" ControlTemplate=\"{StaticResource TealTemplate}\"> <StackLayout VerticalOptions=\"CenterAndExpand\"> <Label Text=\"Welcome to the app!\" HorizontalOptions=\"Center\" /> <Button Text=\"Change Theme\" Clicked=\"OnButtonClicked\" /> </StackLayout> </ContentView> </ContentPage> The TealTemplate is assigned to the ContentView.ControlTemplate property by using the StaticResource markup extension. The ContentView.Content property is set to a StackLayout that defines the content to be displayed on the ContentPage . This content will be displayed by the ContentPresenter contained in the TealTemplate . This results in the appearance shown in the following screenshots: Re-theming an Application at Runtime Clicking the Change Theme button executes the OnButtonClicked method, which is shown in the following code example: void OnButtonClicked (object sender, EventArgs e) { originalTemplate = !originalTemplate; contentView.ControlTemplate = (originalTemplate) ? tealTemplate : aquaTemplate; } Binding from a ControlTemplate Template bindings allow controls in a control temlate to data bind to pubic properties, enabling property calues on controls in the conteol template to be easily changed. This article demonstrates using template bindings to perform data binding from a control template. A TemplateBinding is used to bind a control's property in a control template to a bindable property on the parent of the target view that owns the control template. For example, rather than defining the text displayed by Lable instances inside the ControlTemplate , you can use a template binding to bind the Label.Text property to bindable properties that define the text to be displayed. Note that using a TemplateBinding outside of a ControlTemplate is not supported. Creating a TemplateBinding in XAML In XAML, a TemplateBinding is created using the TemplateBinding markup extension, as demonstrated in the following code example: <ControlTemplate x:Key=\"TealTemplate\"> <Grid> ... <Label Text=\"{TemplateBinding Parent.HeaderText}\" ... /> ... <Label Text=\"{TemplateBinding Parent.FooterText}\" ... /> </Grid> </ControlTemplate> Rather than set the Label.Text properties to static text, the properties can use template bindings to bind to bindable properties on the parent of the target view that owns the ControlTemplate . However, not that the template bindings bind to Parent.HeaderText and Parent.FooterText , rather HeaderText and FooterText . This is because in this example, the bindable properties are defined on the grandparent of the target view, rather than the paren, as demonstrated in the following code example: <ContentPage ...> <ContentView ... ControlTemplate=\"{StaticResource TealTemplate}\"> ... </ContentView> </ContentPage> The template binding uses the Parent property to return the parent element of the ContentView instance, which is the ContentPage instance. Therefore, using a TemplateBinding in the ControlTemplate to bind to Parent.HeaderText and Parent.FooterText locates the bindable properties that are defined on the ContentPage , as demonstrated in the following code example: public static readonly BindableProperty HeaderTextProperty = BindableProperty.Create (\"HeaderText\", typeof(string), typeof(HomePage), \"Control Template Demo App\"); public static readonly BindableProperty FooterTextProperty = BindableProperty.Create (\"FooterText\", typeof(string), typeof(HomePage), \"(c) Xamarin 2016\"); public string HeaderText { get { return (string)GetValue (HeaderTextProperty); } } public string FooterText { get { return (string)GetValue (FooterTextProperty); } } Get more information at here","title":"Xamarin.Forms Control Templates"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/#xamarinforms-control-templates","text":"","title":"Xamarin.Forms Control Templates"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/#introduction","text":"Xamarin.Forms control templates provide the ability to easily theme and re-theme application pages at runtime. This article provides an introduction to control templates. Controls have different properties, such as BackgroundColor and TextColor , that can define aspects of the control's appearance. These properties can be set using styles , which can be chaned at runtime to implement basic theming. However, styles don't maintain a clean separation between the appearance of a page and its content, and the changes that can be made by setting such properties are limited. Control templates provide a clean separation between the appearance of a page and its content, therefore enabling the creation of pages that can easily be themed.","title":"Introduction"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/#creating-a-controltemplate","text":"Control templates can be defined at the application level or at the page level. This article demonstrates how to create and consume control templates. A ControlTemplate specifies the appearence of a page or view, and contains a root layout, and within the layout, the controls that implement the template. Typically, a ControlTemplate will utilize a ContentPresenter to mark where the content to be displayed bu the page or view will appear. The page or view that consumes the ControlTemplate will then define content to be displayed by the ContentPredenter . The following diageam illustrates a ControlTemplate for a page that contains a number of controls, including a ContentPresenter marked by a blue rectangle: A [ ControlTemplate ] can be applied to the following types by setting their ControlTemplate properties: ContentPage ContentView TemplatedPage TemplatedView When a ControlTemplate is created and assigned to these types, any existing appearance is replaced with the appearance defined in the ControlTemplate . in addtion, as well as setting appearance by using the ControlTemplate property, control templats can also be applied by using styles to further expand theme ability. Control templates can be created in XAML and in C#: Control templates created in XAML are defined in a ResourceDictionary that's assigned to the Resource collection of a page, or more typically to the Resources collection of the application. Control templates created in C# are typically defined in the page's class, or in a class that can be globally accessed. Choosing where to define a ControlTemplate instance impacts where it can be used: ControlTemplate instances defined at the page-level can only be applied to the page. ControlTemplate instances defined at the application-level can be applied to page throughout the application.","title":"Creating a ControlTemplate"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/#creating-a-controltemplate-in-xaml","text":"To define a ControlTemplate at the application level, a ResourceDictionary must be added to the App class. By default, all Xamarin.Forms application created from a template use the App class to implement the Application subclass. To declare a ControlTemplate at the application level, in the application's ResourceDictionary using XAM, the default App class must be replaced with a XAML App class and associated code-behind, as shown in the following code example: <Application xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"SimpleTheme.App\"> <Application.Resources> <ResourceDictionary> <ControlTemplate x:Key=\"TealTemplate\"> <Grid> ... <BoxView ... /> <Label Text=\"Control Template Demo App\" TextColor=\"White\" VerticalOptions=\"Center\" ... /> <ContentPresenter ... /> <BoxView Color=\"Teal\" ... /> <Label Text=\"(c) Xamarin 2016\" TextColor=\"White\" VerticalOptions=\"Center\" ... /> </Grid> </ControlTemplate> <ControlTemplate x:Key=\"AquaTemplate\"> ... </ControlTemplate> </ResourceDictionary> </Application.Resources> </Application> Each ControlTemplate instance is created as a reusable object in a ResourceDictionary . This ia achieved by giving each declaration a unique x:Key attribute, which provides it with a descriptive key in the ResourceDictionary . The following code example shows the associated App code-behind: public partial class App : Application { public App () { InitializeComponent (); MainPage = new HomePage (); } } As well as setting the MainPage property, the code-behind must also call the InitializeComponent method to load and parse the associated XAML. The following code example shows a ContentPage applying the TealTemplate to the ContentView : <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"SimpleTheme.HomePage\"> <ContentView x:Name=\"contentView\" Padding=\"0,20,0,0\" ControlTemplate=\"{StaticResource TealTemplate}\"> <StackLayout VerticalOptions=\"CenterAndExpand\"> <Label Text=\"Welcome to the app!\" HorizontalOptions=\"Center\" /> <Button Text=\"Change Theme\" Clicked=\"OnButtonClicked\" /> </StackLayout> </ContentView> </ContentPage> The TealTemplate is assigned to the ContentView.ControlTemplate property by using the StaticResource markup extension. The ContentView.Content property is set to a StackLayout that defines the content to be displayed on the ContentPage . This content will be displayed by the ContentPresenter contained in the TealTemplate . This results in the appearance shown in the following screenshots:","title":"Creating a ControlTemplate in XAML"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/#re-theming-an-application-at-runtime","text":"Clicking the Change Theme button executes the OnButtonClicked method, which is shown in the following code example: void OnButtonClicked (object sender, EventArgs e) { originalTemplate = !originalTemplate; contentView.ControlTemplate = (originalTemplate) ? tealTemplate : aquaTemplate; }","title":"Re-theming an Application at Runtime"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/#binding-from-a-controltemplate","text":"Template bindings allow controls in a control temlate to data bind to pubic properties, enabling property calues on controls in the conteol template to be easily changed. This article demonstrates using template bindings to perform data binding from a control template. A TemplateBinding is used to bind a control's property in a control template to a bindable property on the parent of the target view that owns the control template. For example, rather than defining the text displayed by Lable instances inside the ControlTemplate , you can use a template binding to bind the Label.Text property to bindable properties that define the text to be displayed. Note that using a TemplateBinding outside of a ControlTemplate is not supported.","title":"Binding from a ControlTemplate"},{"location":"knowledge/mobile-development/xamarin/templates/control-templates/#creating-a-templatebinding-in-xaml","text":"In XAML, a TemplateBinding is created using the TemplateBinding markup extension, as demonstrated in the following code example: <ControlTemplate x:Key=\"TealTemplate\"> <Grid> ... <Label Text=\"{TemplateBinding Parent.HeaderText}\" ... /> ... <Label Text=\"{TemplateBinding Parent.FooterText}\" ... /> </Grid> </ControlTemplate> Rather than set the Label.Text properties to static text, the properties can use template bindings to bind to bindable properties on the parent of the target view that owns the ControlTemplate . However, not that the template bindings bind to Parent.HeaderText and Parent.FooterText , rather HeaderText and FooterText . This is because in this example, the bindable properties are defined on the grandparent of the target view, rather than the paren, as demonstrated in the following code example: <ContentPage ...> <ContentView ... ControlTemplate=\"{StaticResource TealTemplate}\"> ... </ContentView> </ContentPage> The template binding uses the Parent property to return the parent element of the ContentView instance, which is the ContentPage instance. Therefore, using a TemplateBinding in the ControlTemplate to bind to Parent.HeaderText and Parent.FooterText locates the bindable properties that are defined on the ContentPage , as demonstrated in the following code example: public static readonly BindableProperty HeaderTextProperty = BindableProperty.Create (\"HeaderText\", typeof(string), typeof(HomePage), \"Control Template Demo App\"); public static readonly BindableProperty FooterTextProperty = BindableProperty.Create (\"FooterText\", typeof(string), typeof(HomePage), \"(c) Xamarin 2016\"); public string HeaderText { get { return (string)GetValue (HeaderTextProperty); } } public string FooterText { get { return (string)GetValue (FooterTextProperty); } } Get more information at here","title":"Creating a TemplateBinding in XAML"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/","text":"Xamarin.Forms Data Templates Introduction Xamarin.Forms data templates provide the ability to dfine the presentation of data on supported controls. This article provides an introduction to data templates, examining why they are necessary. Creating a DataTemplate Data templates can be created inline, in a ResourceDictionary , or fom a custom type or appropriate Xamarin.Forms cell type. An inline template should be used if there's no need to reuse the data template elsewhere. Alternatively, a data template can be reused by definng it as a custom type, or as a control-level, page-level, or application-level resource. A DataTemplate is used to specify the appearance of data, and typically uses data binding to display data. Its common usage scenario is when displaying data from a collection of objects in a ListView . A DataTemplate can be used as a value for the following properties: ListView.HeaderTemplate ListView.FooterTemplate ListView.GroupHeaderTemplate [ ItemsView.ItemTemplate ], which is in herited by ListView . MultiPage.ItemTemplate , which is ingerited by CarouselPage , MasterDetailPage . and TabbedPage . Creating an Inline DataTemplate The elements specified in the DataTemplate define the appearance of each cell, as shown in the following XAML code example: <ListView Margin=\"0,20,0,0\"> <ListView.ItemsSource> <x:Array Type=\"{x:Type local:Person}\"> <local:Person Name=\"Steve\" Age=\"21\" Location=\"USA\" /> <local:Person Name=\"John\" Age=\"37\" Location=\"USA\" /> <local:Person Name=\"Tom\" Age=\"42\" Location=\"UK\" /> <local:Person Name=\"Lucas\" Age=\"29\" Location=\"Germany\" /> <local:Person Name=\"Tariq\" Age=\"39\" Location=\"UK\" /> <local:Person Name=\"Jane\" Age=\"30\" Location=\"USA\" /> </x:Array> </ListView.ItemsSource> <ListView.ItemTemplate> <DataTemplate> <ViewCell> <Grid> ... <Label Text=\"{Binding Name}\" FontAttributes=\"Bold\" /> <Label Grid.Column=\"1\" Text=\"{Binding Age}\" /> <Label Grid.Column=\"2\" Text=\"{Binding Location}\" HorizontalTextAlignment=\"End\" /> </Grid> </ViewCell> </DataTemplate> </ListView.ItemTemplate> </ListView> The child of an inline DataTemplate must be of, or derive from, type Cell . This example uses a ViewCell , which derives from Cell . Layout inside the ViewCell is managed here by a Grid . The Grid contains three Label instances that bind their Text properties to the appropriate properties of each Person object in the collection. Creating a DataTemplate with a Type The ListView.Itemplate property can also be set to a DataTemplate that's created from a cell type. The advantage og this approach is that the appearance defined by the cell type can be reused by multiple data templates throughout the application. The following XAML code shows an example of this approach: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:DataTemplates\" ...> <StackLayout Margin=\"20\"> ... <ListView Margin=\"0,20,0,0\"> <ListView.ItemsSource> <x:Array Type=\"{x:Type local:Person}\"> <local:Person Name=\"Steve\" Age=\"21\" Location=\"USA\" /> ... </x:Array> </ListView.ItemsSource> <ListView.ItemTemplate> <DataTemplate> <local:PersonCell /> </DataTemplate> </ListView.ItemTemplate> </ListView> </StackLayout> </ContentPage> Here, the ListView.ItemTemplate property is set to a DataTemplate that's created from a custom type that defines the cell appearance. The custom type must derive from type ViewCell , as shown in the following code example: <ViewCell xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"DataTemplates.PersonCell\"> <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"0.5*\" /> <ColumnDefinition Width=\"0.2*\" /> <ColumnDefinition Width=\"0.3*\" /> </Grid.ColumnDefinitions> <Label Text=\"{Binding Name}\" FontAttributes=\"Bold\" /> <Label Grid.Column=\"1\" Text=\"{Binding Age}\" /> <Label Grid.Column=\"2\" Text=\"{Binding Location}\" HorizontalTextAlignment=\"End\" /> </Grid> </ViewCell> Creating a DataTemplate as a Resource Data templates can also be created as reusable objects in a ResourceDictionary . This is achieved by giving each declaration a unique x:Key attribute, which provides it with a descriptive key in the Resource Dictionary , as shown in the following XAML code example: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" ...> <ContentPage.Resources> <ResourceDictionary> <DataTemplate x:Key=\"personTemplate\"> <ViewCell> <Grid> ... </Grid> </ViewCell> </DataTemplate> </ResourceDictionary> </ContentPage.Resources> <StackLayout Margin=\"20\"> ... <ListView ItemTemplate=\"{StaticResource personTemplate}\" Margin=\"0,20,0,0\"> <ListView.ItemsSource> <x:Array Type=\"{x:Type local:Person}\"> <local:Person Name=\"Steve\" Age=\"21\" Location=\"USA\" /> ... </x:Array> </ListView.ItemsSource> </ListView> </StackLayout> </ContentPage> Creating a DataTemplateSelector A DataTemplateSelector can be used to choose a DataTemplate at runtime based on the value of a data-bound property. This enables multiple DataTemplate instances to be applied to the same type of object, to customize the appearance of particular objects. This article demonstrates how to create and consume a DataTemplateSelector . A data template selector is implemented by creating a class that inherits from DataTemplateSelector . The OnSelectTemplate method is the overridden to return a particular DataTemplate , as shown in the following code example: public class PersonDataTemplateSelector : DataTemplateSelector { public DataTemplate ValidTemplate { get; set; } public DataTemplate InvalidTemplate { get; set; } protected override DataTemplate OnSelectTemplate (object item, BindableObject container) { return ((Person)item).DateOfBirth.Year >= 1980 ? ValidTemplate : InvalidTemplate; } } Limitations DataTemplateSelector instances have the following limitations: The DataTemplateSelector subclass must always return the same template for the same data if queried multiple times. The DataTemplateSelector subclass must not return another DataTemplateSelector subclass. The DataTemplateSelector sub class must no return new instances of a DataTemplate on each call. Instead, the same instance must be returned. Failure to do so will create a memory leak and will disable virtualization. On Android, there can be no more than 20 different data templates per ListView . Consuming a DataTemlateSelector in XAML In XAML, the PersonDataTemplateSelector can be instantiated by declaring it as a resource, as shown in the following code example: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:Selector;assembly=Selector\" x:Class=\"Selector.HomePage\"> <ContentPage.Resources> <ResourceDictionary> <DataTemplate x:Key=\"validPersonTemplate\"> <ViewCell> ... </ViewCell> </DataTemplate> <DataTemplate x:Key=\"invalidPersonTemplate\"> <ViewCell> ... </ViewCell> </DataTemplate> <local:PersonDataTemplateSelector x:Key=\"personDataTemplateSelector\" ValidTemplate=\"{StaticResource validPersonTemplate}\" InvalidTemplate=\"{StaticResource invalidPersonTemplate}\" /> </ResourceDictionary> </ContentPage.Resources> ... </ContentPage> The PersonDataTemplateSelector instance is consumed by assigned it to the ListView.Itemplate property, as shown in the following code example: <ListView x:Name=\"listView\" ItemTemplate=\"{StaticResource personDataTemplateSelector}\" /> Get more information at here","title":"Xamarin.Forms Data Templates"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#xamarinforms-data-templates","text":"","title":"Xamarin.Forms Data Templates"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#introduction","text":"Xamarin.Forms data templates provide the ability to dfine the presentation of data on supported controls. This article provides an introduction to data templates, examining why they are necessary.","title":"Introduction"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#creating-a-datatemplate","text":"Data templates can be created inline, in a ResourceDictionary , or fom a custom type or appropriate Xamarin.Forms cell type. An inline template should be used if there's no need to reuse the data template elsewhere. Alternatively, a data template can be reused by definng it as a custom type, or as a control-level, page-level, or application-level resource. A DataTemplate is used to specify the appearance of data, and typically uses data binding to display data. Its common usage scenario is when displaying data from a collection of objects in a ListView . A DataTemplate can be used as a value for the following properties: ListView.HeaderTemplate ListView.FooterTemplate ListView.GroupHeaderTemplate [ ItemsView.ItemTemplate ], which is in herited by ListView . MultiPage.ItemTemplate , which is ingerited by CarouselPage , MasterDetailPage . and TabbedPage .","title":"Creating a DataTemplate"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#creating-an-inline-datatemplate","text":"The elements specified in the DataTemplate define the appearance of each cell, as shown in the following XAML code example: <ListView Margin=\"0,20,0,0\"> <ListView.ItemsSource> <x:Array Type=\"{x:Type local:Person}\"> <local:Person Name=\"Steve\" Age=\"21\" Location=\"USA\" /> <local:Person Name=\"John\" Age=\"37\" Location=\"USA\" /> <local:Person Name=\"Tom\" Age=\"42\" Location=\"UK\" /> <local:Person Name=\"Lucas\" Age=\"29\" Location=\"Germany\" /> <local:Person Name=\"Tariq\" Age=\"39\" Location=\"UK\" /> <local:Person Name=\"Jane\" Age=\"30\" Location=\"USA\" /> </x:Array> </ListView.ItemsSource> <ListView.ItemTemplate> <DataTemplate> <ViewCell> <Grid> ... <Label Text=\"{Binding Name}\" FontAttributes=\"Bold\" /> <Label Grid.Column=\"1\" Text=\"{Binding Age}\" /> <Label Grid.Column=\"2\" Text=\"{Binding Location}\" HorizontalTextAlignment=\"End\" /> </Grid> </ViewCell> </DataTemplate> </ListView.ItemTemplate> </ListView> The child of an inline DataTemplate must be of, or derive from, type Cell . This example uses a ViewCell , which derives from Cell . Layout inside the ViewCell is managed here by a Grid . The Grid contains three Label instances that bind their Text properties to the appropriate properties of each Person object in the collection.","title":"Creating an Inline DataTemplate"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#creating-a-datatemplate-with-a-type","text":"The ListView.Itemplate property can also be set to a DataTemplate that's created from a cell type. The advantage og this approach is that the appearance defined by the cell type can be reused by multiple data templates throughout the application. The following XAML code shows an example of this approach: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:DataTemplates\" ...> <StackLayout Margin=\"20\"> ... <ListView Margin=\"0,20,0,0\"> <ListView.ItemsSource> <x:Array Type=\"{x:Type local:Person}\"> <local:Person Name=\"Steve\" Age=\"21\" Location=\"USA\" /> ... </x:Array> </ListView.ItemsSource> <ListView.ItemTemplate> <DataTemplate> <local:PersonCell /> </DataTemplate> </ListView.ItemTemplate> </ListView> </StackLayout> </ContentPage> Here, the ListView.ItemTemplate property is set to a DataTemplate that's created from a custom type that defines the cell appearance. The custom type must derive from type ViewCell , as shown in the following code example: <ViewCell xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" x:Class=\"DataTemplates.PersonCell\"> <Grid> <Grid.ColumnDefinitions> <ColumnDefinition Width=\"0.5*\" /> <ColumnDefinition Width=\"0.2*\" /> <ColumnDefinition Width=\"0.3*\" /> </Grid.ColumnDefinitions> <Label Text=\"{Binding Name}\" FontAttributes=\"Bold\" /> <Label Grid.Column=\"1\" Text=\"{Binding Age}\" /> <Label Grid.Column=\"2\" Text=\"{Binding Location}\" HorizontalTextAlignment=\"End\" /> </Grid> </ViewCell>","title":"Creating a DataTemplate with a Type"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#creating-a-datatemplate-as-a-resource","text":"Data templates can also be created as reusable objects in a ResourceDictionary . This is achieved by giving each declaration a unique x:Key attribute, which provides it with a descriptive key in the Resource Dictionary , as shown in the following XAML code example: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" ...> <ContentPage.Resources> <ResourceDictionary> <DataTemplate x:Key=\"personTemplate\"> <ViewCell> <Grid> ... </Grid> </ViewCell> </DataTemplate> </ResourceDictionary> </ContentPage.Resources> <StackLayout Margin=\"20\"> ... <ListView ItemTemplate=\"{StaticResource personTemplate}\" Margin=\"0,20,0,0\"> <ListView.ItemsSource> <x:Array Type=\"{x:Type local:Person}\"> <local:Person Name=\"Steve\" Age=\"21\" Location=\"USA\" /> ... </x:Array> </ListView.ItemsSource> </ListView> </StackLayout> </ContentPage>","title":"Creating a DataTemplate as a Resource"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#creating-a-datatemplateselector","text":"A DataTemplateSelector can be used to choose a DataTemplate at runtime based on the value of a data-bound property. This enables multiple DataTemplate instances to be applied to the same type of object, to customize the appearance of particular objects. This article demonstrates how to create and consume a DataTemplateSelector . A data template selector is implemented by creating a class that inherits from DataTemplateSelector . The OnSelectTemplate method is the overridden to return a particular DataTemplate , as shown in the following code example: public class PersonDataTemplateSelector : DataTemplateSelector { public DataTemplate ValidTemplate { get; set; } public DataTemplate InvalidTemplate { get; set; } protected override DataTemplate OnSelectTemplate (object item, BindableObject container) { return ((Person)item).DateOfBirth.Year >= 1980 ? ValidTemplate : InvalidTemplate; } }","title":"Creating a DataTemplateSelector"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#limitations","text":"DataTemplateSelector instances have the following limitations: The DataTemplateSelector subclass must always return the same template for the same data if queried multiple times. The DataTemplateSelector subclass must not return another DataTemplateSelector subclass. The DataTemplateSelector sub class must no return new instances of a DataTemplate on each call. Instead, the same instance must be returned. Failure to do so will create a memory leak and will disable virtualization. On Android, there can be no more than 20 different data templates per ListView .","title":"Limitations"},{"location":"knowledge/mobile-development/xamarin/templates/data-templates/#consuming-a-datatemlateselector-in-xaml","text":"In XAML, the PersonDataTemplateSelector can be instantiated by declaring it as a resource, as shown in the following code example: <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\" xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\" xmlns:local=\"clr-namespace:Selector;assembly=Selector\" x:Class=\"Selector.HomePage\"> <ContentPage.Resources> <ResourceDictionary> <DataTemplate x:Key=\"validPersonTemplate\"> <ViewCell> ... </ViewCell> </DataTemplate> <DataTemplate x:Key=\"invalidPersonTemplate\"> <ViewCell> ... </ViewCell> </DataTemplate> <local:PersonDataTemplateSelector x:Key=\"personDataTemplateSelector\" ValidTemplate=\"{StaticResource validPersonTemplate}\" InvalidTemplate=\"{StaticResource invalidPersonTemplate}\" /> </ResourceDictionary> </ContentPage.Resources> ... </ContentPage> The PersonDataTemplateSelector instance is consumed by assigned it to the ListView.Itemplate property, as shown in the following code example: <ListView x:Name=\"listView\" ItemTemplate=\"{StaticResource personDataTemplateSelector}\" /> Get more information at here","title":"Consuming a DataTemlateSelector in XAML"},{"location":"knowledge/mobile-development/xamarin/templates/overview/","text":"Xamarin.Forms Templates Control Templates Xamarin.Forms control templates provide the ability to easily theme and re-theme application pages at runtime. Data Templates Xamarin.Forms data templates provide the ability to define the presentation of data on supported controls. Get more information at here","title":"Overview"},{"location":"knowledge/mobile-development/xamarin/templates/overview/#xamarinforms-templates","text":"","title":"Xamarin.Forms Templates"},{"location":"knowledge/mobile-development/xamarin/templates/overview/#control-templates","text":"Xamarin.Forms control templates provide the ability to easily theme and re-theme application pages at runtime.","title":"Control Templates"},{"location":"knowledge/mobile-development/xamarin/templates/overview/#data-templates","text":"Xamarin.Forms data templates provide the ability to define the presentation of data on supported controls. Get more information at here","title":"Data Templates"},{"location":"knowledge/stories/blockchain-blog/matic-developer-support-program/","text":"Matic Developer Support Program The major hurdles that developers face while developing Blockchain'based applications are: Finacials issues (runway to create at least a basic MVP) Talent sourcing (It is both expensive and hard to come by in the blockchain space) Techniques issues like Scaling , UI/UX Design Develop Tools Reaching out to investor after MVP stage is complete, especial when you are not based out of Blockchain Hubs. Developer Support Program( DSP ) will provide developers/teams building Ethereum/Matic with: Techniques guiden our teams and network Early Support Giants . Security audit support . Helping with investor connections . Marketing & promotional support . Access to Matic Sponsored Hackathon to test product ideas and recuit talent . Get more information at here","title":"Matic Developer Support Program"},{"location":"knowledge/stories/blockchain-blog/matic-developer-support-program/#matic-developer-support-program","text":"The major hurdles that developers face while developing Blockchain'based applications are: Finacials issues (runway to create at least a basic MVP) Talent sourcing (It is both expensive and hard to come by in the blockchain space) Techniques issues like Scaling , UI/UX Design Develop Tools Reaching out to investor after MVP stage is complete, especial when you are not based out of Blockchain Hubs. Developer Support Program( DSP ) will provide developers/teams building Ethereum/Matic with: Techniques guiden our teams and network Early Support Giants . Security audit support . Helping with investor connections . Marketing & promotional support . Access to Matic Sponsored Hackathon to test product ideas and recuit talent . Get more information at here","title":"Matic Developer Support Program"},{"location":"knowledge/stories/blockchain-blog/plasma/","text":"Plasma: Scalable Autonomous Smart Contracts Get more information at here","title":"Plasma"},{"location":"knowledge/stories/blockchain-blog/plasma/#plasma-scalable-autonomous-smart-contracts","text":"Get more information at here","title":"Plasma: Scalable Autonomous Smart Contracts"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/","text":"What is Matic Network? Introduction Matric network is layer 2 scaling solution that achieves scale by utility sidechains for off-chain but ensuring asset security using the Plasma Framework and a decentralization network of Proof-of-Stake(PoS). Matric strives to solve scalability and usibility issues while not compromise on decentralization and laveraging the existing developer community and ecosytem. Matic network is an off/side chain scaling solution for existing platforms to provide scalability and superior user experimence to DApps/ user functionality. Key Features and Highlights Scalability : Fast, low-cost and secure transaction on Matic sidechains with finality mainchain and Ethereum as the first compatible Layer 1 basechain. High Throughout : Achived up to 10.000 TPS on a single sidechains on internal testnet and multiple chains to be added for horizontal scaling. User Experience : Smooth UX and developer abstraction from mainchain to Matic Chain, native mobile app and SDK with WalletConnect support. Security : Matic chain operators are themselves stakers in the PoS system. Public Sidechain : Matic mainchains are public in nature(. vs individual DApps chains), permissionless and capable of supporting multiple protocols. Value Propostion Matic is unique in terms of techniqual approach towards Layer 2 as well as its potential support for a variety use cases. Matic Layer 2 is an account-based veriant MoreVP( More Visible Plasma). The Plasma Framework is used to guarentee the security of assets on the main chain(such as ERC-20 and ERC-721 tokens for Ethereums). While generic transaction is secured by the Proof on Stakes, built on top of Tendermint. Matic sidechains is essentially EVM-enabled chain and conducive to the ready deployment of solidity smart contracts, essential to make it an easy tool for Ethereum Developer to use it for scaling their DApps/Protocals. Commercially, Matic sidechains are structurally effective for supporting the many Decentralized Finance(DeFi) Protocols availlable in the Ethereum ecosystem. Matic's core philosophy is to anable DApps to compete with the user experence that is offered by centralized apps today. Ethereum is the first basechain Matic Network supports, but Matic intends to offer for additional basechain based on community sugession and consensus, to enable an interoperable descentralized Layer 2 Blockchain platform. Matic strives to achieve a high degree of decentralizationn with trust -less and decentralized execution while ensuring near instant transfers, low fees and conducive economics for micro-transactions. Matic's open source foundation intends to provide the Matic Wallet, payment APIs and SDKs, products, identity solutions and other enabling solutions that will allow developers to design, implwment and migreate DApps built on base platforms like Ethereum. One of the key pillars of Matic Network's ideology is user experience which is very poor for blockchain applications as of now. The Matic team already built high quality Mobile/Web browser libraries with great developer experience, which will enable business to create real world end user applications at large scale. Matic roadmap also includes supporting cross-chain transfers and third party Decentralized exchanges, liquidity pools etc. Problems Decentralized Apps are making huge progress but the current blockchain ecosystem is not prepared to scale as per the demand. Slow block confirmations, block size limitations and computations- in smart contract based blockchains - need to be solved before we target mass adoption by mainstream users. And most importantly, it needs awesome user experience. Some of the problems associated with the current blockchain platforms are as follows: Slow transactions Blockchain transactions are slow and have variable, sometimes exasperating transaction times. Most blockchain protocols have a limit on the block size and it can take a certain amount of tiem to generate a block. Each transaction also has to wati for multiple block confirmations due to potential chain reorganizations. These limitations are often necessary for a public blockchain as a block need to be validated and must be downloaded bu a certain number of nodes to keep it really decentralized. High transactions fees Day by day, the blockchain market is growing and crypto assets are increasingly being created, transferred, and sold, often involving multiple cryto tokens. Every decentralized applications has it'own token and economy. Paying them for their services requires on-chain transfer. Etherrum charges gas fees on each transaction. Fees are an important factor to reward validators and prevent certain kind of security attacks like DoS. But, the problem is that fees vary depending upon the pending transaction pool size due to the limited block size. Low transaction throughput Public blockchains have to maintain a certain amount of time lag between intermediate block production so as to ensure ample time for block propagation. Also, the eblock size need s to be low, so as to ensure quick propagation of the block through the network. This means that the number of transactions in a particular block needs to be fairly limited. Scalability Each block on a blockchain mlust be validated by multiple nodes and/or compute state in case of a smart contract based blockchain. Each node has to manage a copy of the state and all blocks. While the chain size is increasing day by day, maintaining and validation the whole blockchain is correspondingly setting more difficult. This is a huge risk for decentralization as an idea, overall. Multiple micropayment channels Some payment channel solutions solve the problem of micro-payments. However, opening and managing channels with multiple DApps or users is complex. Additionally, the speed and convenience of mediated payments over channels is still up for debate. Poor usability The current system is inherently bad for normal users. Asthe number of ICO increases, users may want to use DApps with different tokens as payment. Without on-chain trade, the convertibility of one crypto token to another represents a new challenge for both investors alive. It introduces complexity for managing multiple crypto tokens and exchanging tokens to pay on different platforms. Matic Network Matic Network solves these problems bu building a decentralized platform using an adated version of Plasma framework that provises a solution for faster and extremelu low cost transactions with finality on a main chain. Matic Network solves the low transaction throughout problem by using a Block Producer layer to produce the blocks. Block Producers enable the system to produce blocks at a very fast rate. The system ensures decentralization using PoS checkpoints which are pushed to the Ethereum mainchain. This enables Matic to theoretically achieve 2^16 transation on a single side chain. In addition, we are developing a suite of developer tools such as the real-time notification engine for Etherum events - Dagger and a scalable, modular and realtime Ethereum data processor - hermione. Apart from this, the Matic team actively contributes to the WalletConnect protocol implementation. Architecture When a user is transferring ETH or ERC20 tokens, they have to wait for block confirmation times which ranges from 14 seconds to 20 seconds. Also you have to wait for multiple blocks to be sure of the finaltity of the block inclusion in the chain. That's a deterrent for users to use the service. As crytocurrency gains favor, more transactions will jam the Ethereum network and gas fees will increae on an average for each transactionn for faster confirmations by users. Note that gas fees vary as per traffic and confirmation time. We propose Matic as a solution to overcome these problems. Here is how Matic works: User deposits crypto assets in the Matic contract on mainchain (currently implemented with Ethereum blockchain only) Once deposited tokens get confirmed on the main chain, the corresponding tokens will ger reflected on the Matic chain. The user can now transfer tokens to anyone they want instantly with negligible fees . Matic chain has faster blocks (approximately 1 second or less). That way, the transfer will be done almost instantly. Once a user is ready, they can withdraw remaining tokens from the main chain by establishing proof of remaining tokens on Root contract (contract deployed on Ethereum chain) Remember any fungible crypto assets can be rerpresented as ERC20 tokens on Matic chain. That way, the same method will work for any fungible crypto assets. In addition, we have also added support for ERC721/ NFTs (Non Fungible Tokens). Check out on Githuh repos . Consensus and security To provide some context, the Matic ecosystem will have the following actor: End Users. DApp developers: Developers are expected to use the Matic Network to scale their applications and provide a better UI/UX to their end users Stakers Stakes need to deposit/stake tokens to qualify and play a very important role in the Matic Network. They validate the transactions and propose checkpoints on the mainchain using PoS consensus mechaism with a 2/3 majority. They also choose Block Producers amongst themselves, who satisfy a certain criteria, to produce blocks on the sidechains. Block Producers: These are block producers chosen by Stakers who in turn enable faster blockchain generationn times. They have to provide a significant stake to be nominated. The Matic Network uses a dual strategy of Proof of Stake at the checkpointing layer and Block Producers at the block producer layer to achieve faster blocktimes while ensuring a high degree of decentralization by achieveing finality on the main chains using the checkpoints and fraid prood mechanisms . Bassically, anyone can stake their Matic tokens on root contract to become a Staker in the PoS checkpointing layer (contract deployed on Ethereum chain). This provides a high degree decentralized base layer for Matic chain. At the blockchain layer of the Matic Network, there are Block Producers, selected by PoS Stakers on the base layer, who will be creating the Matic Blocks. To achieve faster block generation times, these Block Producers will be low in number. This layer is expexted to achieve ~ second block generation times at extremely low to negligible transaction fees. On Matic Network's chackpointing layer, the basis of Matic Network's PoS mechanism, for every few blocks on the block layer of the Matic Network, a proposer will be chosen among the stakeholders to propose a checkpoint on the main chain. These checkpoints are created by the proposer after validating all the blocks on the block layer of the Matic Network and creating the Merkle tree of the block hashes since the last checkpoint. The Merkle root is the broadcasted to the Staker Network for their signatures. The order stakeholders also verify the proof. They will approve the proposed blocks, if it is valid, by providing their signatures. The system needs the approval of 2/3 of the stakeholders to propose a \"header block\" to the root contract. Once the checkpoint is proposed on the mainchain, anyone on the Ethereum mainchain can challenge the proposed checkpoint within a specified prrod of time. if no one challenges it and the challenge period ends, the checkpoint if formally included as a valid checkpoint on the main chain. Following is a illustration of the \"Header block\": More on header block AKA checkpoint at here . Fraud Proofs To enhance the security of the transactions, Matic Network also provides Fraud Proofs on the mainchain. The mechanism enables any individual on the mainchain to submit the details of the transactions which he/sh thinks is fraudulent. If the challenge is successful, the stakes of the parties involved in the fraud are shared and the challenger receives the slashed funds as an incentive for detecting the fraud. This can be considered as an always-running high reward bounty program for any parties who widh to investigate the veracity of the transactionns on the Matic Network. Multi Chain Support (Horizontal Sharding) The Matic Network public checkpointing layer supports multiple side chains by design. Theoretically, there can be an infinite number of side chains working under the secured and decentrailized layer of checkpoints. Businesses can have their dedicated side chains connected to the public checkpointing layer having full control of their execution environments, while still retaining the immutability, provability and security of transactions via the checkpointing mechanism. Key factors influencing the design of this sharding process are expected to be: Scheduling of checkpointing layer to periodically propose checkpoints for different side chains. Movement of assets across multiple side chains 2.1 User will be able to send assets across side chains using chain ids and receipts. 2.2 Users will be provided with an intuitive wallet interface to perform interchain transactions. 2.3 Developers will be provided with API/SDKs to build programmable interfaces for inter chain transactions. Movement of the assets from one chain to another will be managed at the checkpointing layer and may not require any interaction with the mainchain. Research is currently underway to facilitate faster (possibly instant) inter sidechain transfers. Potential Use Cases Matic Foundation is committed to provide a scalable and user friendly ecosystem for third party Decentralized applications to thrive on. Matic Foundation like Ethereum and other platform foundations will promote various Base chain DApps(like DApps built Ethereum currently, and NEO, EOS in the future) to build and migrate their user facing applications/ transactions on Matic Network. It will also award grants and funding to third party app developers to buld various user cases on top of Matic Network like: Payments The Matic Network will provide an interface for users, payment APIs and SDKs for DApps, merchant and users to instantly accept or pay in crypto assets. Atomic swaps Matic smart contracts will allow users to pay with any crypto token thay prefer and receiver will receive payment in assets thay prefer. Matic will handle conversion through atomic swap between cross-chain crypto assets. Liquidity providers Third parties can use the Matic Network to exchange any tokens for other tokens by leveraging 0x liquidity pool or other liquidity providers while transferring crypto assets. In the case of fiat, the Matic Development Team is planning to collaborate with fiat liquidity providers in currencies of major countries. Decentralized Exchange (DEX) and Marketplace support The Matic Network is expected to have all characteristics which an exchange platform should have - faster and cheapers trades. The Matic Network is capable of supporting decentralized exchanges and enabling trust-less, reliable and easy crypto trades. The decentralized exchange is the future for digital assets and provides better security or solvency than the centralized exchanges. Lending platform The Matic Network will enable platforms for merchants to assess the creditworthiness of connected users via their transaction history. This enables merchants to len tokens to users on the network when transacting with users that fon not have sufficient funds. The Matic Network expects to use the Dharma protocol to provide tokenized debt to users. Identity Users need utilitarian yet user-friendly interface where MetaMask or web3 enabled browsers are not required. Thay do not need to understand how Ethereum works under the hood. Decentralized apps need a way to sign transactions, but that must happen without submitting private keys on each DApp on wen browser or mobile apps. The Matic Development Team believes that users must have control over their private keys withour worrying about the security. The Matic Network will solve that with Open-Identity system and will deliver a seamless experience to users. This system will also provide a way to auto-approve certain kind of transactions depending upon the criteria chosen by the users. This will drive the recurring payments on the Matic Network. Games We expect games to be a big part of the Matic Network. In-game assets represented as NFTs (ERC721) are expected to be bought, sold and traded in huge numbers on our sidechains. Developers will also be able to save game state on the sidechains, if they choose to. Along with the NFT marketplace that we will enable,developers and users will truly have a fast, efficient and secure sidechain to build and play games on. Infrastructure The Matic Development Team will act on the simple mantra - make it simple and seamless. For that, the team will provide new infrastructure around the Matic Network including user-friendly wallets for individual users and merchants, payroll dashboards, payment SDKs and other open source tools. Dagger Dagger is a tool or engine to track Ethereum accounts and events in real-time. We can learn more about Dagger here and check how it works at here . Developers can use Dagger to track their own smart contracts, accounts and transactions. They can create custom service or integrate with third-party services through IFTTT or Zapier. Partners (partial list) Decentraland : Decentraland is a virtual reality platform powered by the Ethereum blockchain. Users can create, experience, and monetize content and applications using a developer toolkit that works on any platform (all VR headsets and web browsers) and is designed to create virtual environments an applications. Quarkchain : QuarkChain is an innovative permissionless blockchain architecture that aims to provide a secure, decentralized and scalable blockchain solution. Ankr Network : Ankr is a distributed computing platform that aims to leverage idle computing resources in data centres and edge devices. Portis : Portis is a technology company that wants to make sure any person in the world can use decentralized application, just as easily as they use \"regular\" apps. Maker DAO : Maker is the organization behind the DAI stablecoin. Ripio Credit Network : Ripio Credit Network is a peer to peer credit network that connects lenders and borrowsers located anywhere in the world. Get more information at here .","title":"What Is Matic Network"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#what-is-matic-network","text":"","title":"What is Matic Network?"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#introduction","text":"Matric network is layer 2 scaling solution that achieves scale by utility sidechains for off-chain but ensuring asset security using the Plasma Framework and a decentralization network of Proof-of-Stake(PoS). Matric strives to solve scalability and usibility issues while not compromise on decentralization and laveraging the existing developer community and ecosytem. Matic network is an off/side chain scaling solution for existing platforms to provide scalability and superior user experimence to DApps/ user functionality.","title":"Introduction"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#key-features-and-highlights","text":"Scalability : Fast, low-cost and secure transaction on Matic sidechains with finality mainchain and Ethereum as the first compatible Layer 1 basechain. High Throughout : Achived up to 10.000 TPS on a single sidechains on internal testnet and multiple chains to be added for horizontal scaling. User Experience : Smooth UX and developer abstraction from mainchain to Matic Chain, native mobile app and SDK with WalletConnect support. Security : Matic chain operators are themselves stakers in the PoS system. Public Sidechain : Matic mainchains are public in nature(. vs individual DApps chains), permissionless and capable of supporting multiple protocols.","title":"Key Features and Highlights"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#value-propostion","text":"Matic is unique in terms of techniqual approach towards Layer 2 as well as its potential support for a variety use cases. Matic Layer 2 is an account-based veriant MoreVP( More Visible Plasma). The Plasma Framework is used to guarentee the security of assets on the main chain(such as ERC-20 and ERC-721 tokens for Ethereums). While generic transaction is secured by the Proof on Stakes, built on top of Tendermint. Matic sidechains is essentially EVM-enabled chain and conducive to the ready deployment of solidity smart contracts, essential to make it an easy tool for Ethereum Developer to use it for scaling their DApps/Protocals. Commercially, Matic sidechains are structurally effective for supporting the many Decentralized Finance(DeFi) Protocols availlable in the Ethereum ecosystem. Matic's core philosophy is to anable DApps to compete with the user experence that is offered by centralized apps today. Ethereum is the first basechain Matic Network supports, but Matic intends to offer for additional basechain based on community sugession and consensus, to enable an interoperable descentralized Layer 2 Blockchain platform. Matic strives to achieve a high degree of decentralizationn with trust -less and decentralized execution while ensuring near instant transfers, low fees and conducive economics for micro-transactions. Matic's open source foundation intends to provide the Matic Wallet, payment APIs and SDKs, products, identity solutions and other enabling solutions that will allow developers to design, implwment and migreate DApps built on base platforms like Ethereum. One of the key pillars of Matic Network's ideology is user experience which is very poor for blockchain applications as of now. The Matic team already built high quality Mobile/Web browser libraries with great developer experience, which will enable business to create real world end user applications at large scale. Matic roadmap also includes supporting cross-chain transfers and third party Decentralized exchanges, liquidity pools etc.","title":"Value Propostion"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#problems","text":"Decentralized Apps are making huge progress but the current blockchain ecosystem is not prepared to scale as per the demand. Slow block confirmations, block size limitations and computations- in smart contract based blockchains - need to be solved before we target mass adoption by mainstream users. And most importantly, it needs awesome user experience. Some of the problems associated with the current blockchain platforms are as follows:","title":"Problems"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#slow-transactions","text":"Blockchain transactions are slow and have variable, sometimes exasperating transaction times. Most blockchain protocols have a limit on the block size and it can take a certain amount of tiem to generate a block. Each transaction also has to wati for multiple block confirmations due to potential chain reorganizations. These limitations are often necessary for a public blockchain as a block need to be validated and must be downloaded bu a certain number of nodes to keep it really decentralized.","title":"Slow transactions"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#high-transactions-fees","text":"Day by day, the blockchain market is growing and crypto assets are increasingly being created, transferred, and sold, often involving multiple cryto tokens. Every decentralized applications has it'own token and economy. Paying them for their services requires on-chain transfer. Etherrum charges gas fees on each transaction. Fees are an important factor to reward validators and prevent certain kind of security attacks like DoS. But, the problem is that fees vary depending upon the pending transaction pool size due to the limited block size.","title":"High transactions fees"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#low-transaction-throughput","text":"Public blockchains have to maintain a certain amount of time lag between intermediate block production so as to ensure ample time for block propagation. Also, the eblock size need s to be low, so as to ensure quick propagation of the block through the network. This means that the number of transactions in a particular block needs to be fairly limited.","title":"Low transaction throughput"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#scalability","text":"Each block on a blockchain mlust be validated by multiple nodes and/or compute state in case of a smart contract based blockchain. Each node has to manage a copy of the state and all blocks. While the chain size is increasing day by day, maintaining and validation the whole blockchain is correspondingly setting more difficult. This is a huge risk for decentralization as an idea, overall.","title":"Scalability"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#multiple-micropayment-channels","text":"Some payment channel solutions solve the problem of micro-payments. However, opening and managing channels with multiple DApps or users is complex. Additionally, the speed and convenience of mediated payments over channels is still up for debate.","title":"Multiple micropayment channels"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#poor-usability","text":"The current system is inherently bad for normal users. Asthe number of ICO increases, users may want to use DApps with different tokens as payment. Without on-chain trade, the convertibility of one crypto token to another represents a new challenge for both investors alive. It introduces complexity for managing multiple crypto tokens and exchanging tokens to pay on different platforms.","title":"Poor usability"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#matic-network","text":"Matic Network solves these problems bu building a decentralized platform using an adated version of Plasma framework that provises a solution for faster and extremelu low cost transactions with finality on a main chain. Matic Network solves the low transaction throughout problem by using a Block Producer layer to produce the blocks. Block Producers enable the system to produce blocks at a very fast rate. The system ensures decentralization using PoS checkpoints which are pushed to the Ethereum mainchain. This enables Matic to theoretically achieve 2^16 transation on a single side chain. In addition, we are developing a suite of developer tools such as the real-time notification engine for Etherum events - Dagger and a scalable, modular and realtime Ethereum data processor - hermione. Apart from this, the Matic team actively contributes to the WalletConnect protocol implementation.","title":"Matic Network"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#architecture","text":"When a user is transferring ETH or ERC20 tokens, they have to wait for block confirmation times which ranges from 14 seconds to 20 seconds. Also you have to wait for multiple blocks to be sure of the finaltity of the block inclusion in the chain. That's a deterrent for users to use the service. As crytocurrency gains favor, more transactions will jam the Ethereum network and gas fees will increae on an average for each transactionn for faster confirmations by users. Note that gas fees vary as per traffic and confirmation time. We propose Matic as a solution to overcome these problems.","title":"Architecture"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#here-is-how-matic-works","text":"User deposits crypto assets in the Matic contract on mainchain (currently implemented with Ethereum blockchain only) Once deposited tokens get confirmed on the main chain, the corresponding tokens will ger reflected on the Matic chain. The user can now transfer tokens to anyone they want instantly with negligible fees . Matic chain has faster blocks (approximately 1 second or less). That way, the transfer will be done almost instantly. Once a user is ready, they can withdraw remaining tokens from the main chain by establishing proof of remaining tokens on Root contract (contract deployed on Ethereum chain) Remember any fungible crypto assets can be rerpresented as ERC20 tokens on Matic chain. That way, the same method will work for any fungible crypto assets. In addition, we have also added support for ERC721/ NFTs (Non Fungible Tokens). Check out on Githuh repos .","title":"Here is how Matic works:"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#consensus-and-security","text":"To provide some context, the Matic ecosystem will have the following actor: End Users. DApp developers: Developers are expected to use the Matic Network to scale their applications and provide a better UI/UX to their end users Stakers Stakes need to deposit/stake tokens to qualify and play a very important role in the Matic Network. They validate the transactions and propose checkpoints on the mainchain using PoS consensus mechaism with a 2/3 majority. They also choose Block Producers amongst themselves, who satisfy a certain criteria, to produce blocks on the sidechains. Block Producers: These are block producers chosen by Stakers who in turn enable faster blockchain generationn times. They have to provide a significant stake to be nominated. The Matic Network uses a dual strategy of Proof of Stake at the checkpointing layer and Block Producers at the block producer layer to achieve faster blocktimes while ensuring a high degree of decentralization by achieveing finality on the main chains using the checkpoints and fraid prood mechanisms . Bassically, anyone can stake their Matic tokens on root contract to become a Staker in the PoS checkpointing layer (contract deployed on Ethereum chain). This provides a high degree decentralized base layer for Matic chain. At the blockchain layer of the Matic Network, there are Block Producers, selected by PoS Stakers on the base layer, who will be creating the Matic Blocks. To achieve faster block generation times, these Block Producers will be low in number. This layer is expexted to achieve ~ second block generation times at extremely low to negligible transaction fees. On Matic Network's chackpointing layer, the basis of Matic Network's PoS mechanism, for every few blocks on the block layer of the Matic Network, a proposer will be chosen among the stakeholders to propose a checkpoint on the main chain. These checkpoints are created by the proposer after validating all the blocks on the block layer of the Matic Network and creating the Merkle tree of the block hashes since the last checkpoint. The Merkle root is the broadcasted to the Staker Network for their signatures. The order stakeholders also verify the proof. They will approve the proposed blocks, if it is valid, by providing their signatures. The system needs the approval of 2/3 of the stakeholders to propose a \"header block\" to the root contract. Once the checkpoint is proposed on the mainchain, anyone on the Ethereum mainchain can challenge the proposed checkpoint within a specified prrod of time. if no one challenges it and the challenge period ends, the checkpoint if formally included as a valid checkpoint on the main chain. Following is a illustration of the \"Header block\": More on header block AKA checkpoint at here .","title":"Consensus and security"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#fraud-proofs","text":"To enhance the security of the transactions, Matic Network also provides Fraud Proofs on the mainchain. The mechanism enables any individual on the mainchain to submit the details of the transactions which he/sh thinks is fraudulent. If the challenge is successful, the stakes of the parties involved in the fraud are shared and the challenger receives the slashed funds as an incentive for detecting the fraud. This can be considered as an always-running high reward bounty program for any parties who widh to investigate the veracity of the transactionns on the Matic Network.","title":"Fraud Proofs"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#multi-chain-support-horizontal-sharding","text":"The Matic Network public checkpointing layer supports multiple side chains by design. Theoretically, there can be an infinite number of side chains working under the secured and decentrailized layer of checkpoints. Businesses can have their dedicated side chains connected to the public checkpointing layer having full control of their execution environments, while still retaining the immutability, provability and security of transactions via the checkpointing mechanism. Key factors influencing the design of this sharding process are expected to be: Scheduling of checkpointing layer to periodically propose checkpoints for different side chains. Movement of assets across multiple side chains 2.1 User will be able to send assets across side chains using chain ids and receipts. 2.2 Users will be provided with an intuitive wallet interface to perform interchain transactions. 2.3 Developers will be provided with API/SDKs to build programmable interfaces for inter chain transactions. Movement of the assets from one chain to another will be managed at the checkpointing layer and may not require any interaction with the mainchain. Research is currently underway to facilitate faster (possibly instant) inter sidechain transfers.","title":"Multi Chain Support (Horizontal Sharding)"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#potential-use-cases","text":"Matic Foundation is committed to provide a scalable and user friendly ecosystem for third party Decentralized applications to thrive on. Matic Foundation like Ethereum and other platform foundations will promote various Base chain DApps(like DApps built Ethereum currently, and NEO, EOS in the future) to build and migrate their user facing applications/ transactions on Matic Network. It will also award grants and funding to third party app developers to buld various user cases on top of Matic Network like:","title":"Potential Use Cases"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#payments","text":"The Matic Network will provide an interface for users, payment APIs and SDKs for DApps, merchant and users to instantly accept or pay in crypto assets.","title":"Payments"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#atomic-swaps","text":"Matic smart contracts will allow users to pay with any crypto token thay prefer and receiver will receive payment in assets thay prefer. Matic will handle conversion through atomic swap between cross-chain crypto assets.","title":"Atomic swaps"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#liquidity-providers","text":"Third parties can use the Matic Network to exchange any tokens for other tokens by leveraging 0x liquidity pool or other liquidity providers while transferring crypto assets. In the case of fiat, the Matic Development Team is planning to collaborate with fiat liquidity providers in currencies of major countries.","title":"Liquidity providers"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#decentralized-exchange-dex-and-marketplace-support","text":"The Matic Network is expected to have all characteristics which an exchange platform should have - faster and cheapers trades. The Matic Network is capable of supporting decentralized exchanges and enabling trust-less, reliable and easy crypto trades. The decentralized exchange is the future for digital assets and provides better security or solvency than the centralized exchanges.","title":"Decentralized Exchange (DEX) and Marketplace support"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#lending-platform","text":"The Matic Network will enable platforms for merchants to assess the creditworthiness of connected users via their transaction history. This enables merchants to len tokens to users on the network when transacting with users that fon not have sufficient funds. The Matic Network expects to use the Dharma protocol to provide tokenized debt to users.","title":"Lending platform"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#identity","text":"Users need utilitarian yet user-friendly interface where MetaMask or web3 enabled browsers are not required. Thay do not need to understand how Ethereum works under the hood. Decentralized apps need a way to sign transactions, but that must happen without submitting private keys on each DApp on wen browser or mobile apps. The Matic Development Team believes that users must have control over their private keys withour worrying about the security. The Matic Network will solve that with Open-Identity system and will deliver a seamless experience to users. This system will also provide a way to auto-approve certain kind of transactions depending upon the criteria chosen by the users. This will drive the recurring payments on the Matic Network.","title":"Identity"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#games","text":"We expect games to be a big part of the Matic Network. In-game assets represented as NFTs (ERC721) are expected to be bought, sold and traded in huge numbers on our sidechains. Developers will also be able to save game state on the sidechains, if they choose to. Along with the NFT marketplace that we will enable,developers and users will truly have a fast, efficient and secure sidechain to build and play games on.","title":"Games"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#infrastructure","text":"The Matic Development Team will act on the simple mantra - make it simple and seamless. For that, the team will provide new infrastructure around the Matic Network including user-friendly wallets for individual users and merchants, payroll dashboards, payment SDKs and other open source tools.","title":"Infrastructure"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#dagger","text":"Dagger is a tool or engine to track Ethereum accounts and events in real-time. We can learn more about Dagger here and check how it works at here . Developers can use Dagger to track their own smart contracts, accounts and transactions. They can create custom service or integrate with third-party services through IFTTT or Zapier.","title":"Dagger"},{"location":"knowledge/stories/blockchain-blog/what-is-matic-network/#partners-partial-list","text":"Decentraland : Decentraland is a virtual reality platform powered by the Ethereum blockchain. Users can create, experience, and monetize content and applications using a developer toolkit that works on any platform (all VR headsets and web browsers) and is designed to create virtual environments an applications. Quarkchain : QuarkChain is an innovative permissionless blockchain architecture that aims to provide a secure, decentralized and scalable blockchain solution. Ankr Network : Ankr is a distributed computing platform that aims to leverage idle computing resources in data centres and edge devices. Portis : Portis is a technology company that wants to make sure any person in the world can use decentralized application, just as easily as they use \"regular\" apps. Maker DAO : Maker is the organization behind the DAI stablecoin. Ripio Credit Network : Ripio Credit Network is a peer to peer credit network that connects lenders and borrowsers located anywhere in the world. Get more information at here .","title":"Partners (partial list)"},{"location":"knowledge/stories/docker-labs/overview/","text":"A Docker Captain's Blog Welcome to DockerLabs Are you new to Docker? Looking out for building Your Career in DevOps & Containers Technology? Welcome! You are at the right place. DockerLabs brings you tutorials that help you get hands-on experience using Docker & Kubernetes. Here you woll find complete documentation of labs and tutorials that will help you, no matter if you are a beginner, SysAdmin, IT Pro or Developer. Yes, you read it right! Its \\$0 learning platform. You don't need any infrastructure. Most of the tutorials runs on Play with Docker Platform & Play with Kubernetes Platform . This is a free browser based learning platform for you. Docker tools like Docker Engine, Docker Compose & Docker Machine are already installed. Hence, we have everything ready for you to get started with. Get more information at here .","title":"A Docker Captain's Blog"},{"location":"knowledge/stories/docker-labs/overview/#a-docker-captains-blog","text":"","title":"A Docker Captain's Blog"},{"location":"knowledge/stories/docker-labs/overview/#welcome-to-dockerlabs","text":"Are you new to Docker? Looking out for building Your Career in DevOps & Containers Technology? Welcome! You are at the right place. DockerLabs brings you tutorials that help you get hands-on experience using Docker & Kubernetes. Here you woll find complete documentation of labs and tutorials that will help you, no matter if you are a beginner, SysAdmin, IT Pro or Developer. Yes, you read it right! Its \\$0 learning platform. You don't need any infrastructure. Most of the tutorials runs on Play with Docker Platform & Play with Kubernetes Platform . This is a free browser based learning platform for you. Docker tools like Docker Engine, Docker Compose & Docker Machine are already installed. Hence, we have everything ready for you to get started with. Get more information at here .","title":"Welcome to DockerLabs"},{"location":"knowledge/stories/thinking-in-art/you-could-have-today-instead-you-choose-tomorrow/","text":"You Could Have Today Instead You Choose Tomorrow Get More Information at Here .","title":"You Could Have Today Intead You Choose Tomorrow"},{"location":"knowledge/stories/thinking-in-art/you-could-have-today-instead-you-choose-tomorrow/#you-could-have-today-instead-you-choose-tomorrow","text":"Get More Information at Here .","title":"You Could Have Today Instead You Choose Tomorrow"},{"location":"knowledge/web-development/ruby-on-rails/rails-active-record-callbacks/","text":"Active Recore Callbacks Get more information at here .","title":"Active Record Callbacks"},{"location":"knowledge/web-development/ruby-on-rails/rails-active-record-callbacks/#active-recore-callbacks","text":"Get more information at here .","title":"Active Recore Callbacks"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/","text":"Rails form_with - alternative to form_for and form_tag Rails 5.1 added form_with form helper method that provides capabilities of form_for and form_tag . Rails unified form_for and form_tag that provide similar interfaces to generate forms with form_with helper. - form_for was being used to generate for a new/existing model object. - form_tag was used to create form withour a model object by passing a URL to submit the form. Before Rails 5.1 form_for with model object - form_for was used when we had to create a form for a model object. <%= form_for User.new do |form| %> <%= form.text_field :name%> <%= form.text_field :email%> <%= form.submit%> <% end %> This generates DOM shown below. <form class=\"new_user\" id=\"new_user\" actionn=\"/users\" accept-charset=\"UTF-8\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2712;\" /> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"/> <input type=\"text\" name=\"user[password]\" id=\"user_password\"/> <input type=\"text\" name=\"user[email]\" value=\"\" id=\"user_email\"/> <input type=\"submit\" name=\"submit\" value=\"create User\" data-disable-with=\"Create User\" /> </form> Behavior: We can see Rails automatically assigns id attribute value to the new_user if record is new. id attribute is set to edit_user_<id> , where <id> is the primary key of users table. It fills out the input values if the model object is not new. After Rails 5.1 form_with with a model object <%= form_with model: @user do |form| %> <%= form.text_field :email %> <%= form.submit %> <% end %> This generates DOM given below. <form action=\"/users\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713\"/> <input type=\"hidden\" name=\"authenticaity_token\" value=\"token_value\"/> <input type=\"text\" name=\"email\" /> <input type=\"submit\" name=\"commit\" value=\"Save \" data-disable-with=\"SAVE \"> </form> Behavior: Automatic IDs for the form are gone. The above way of creating form works for both new and existing records. It fills out the input values if the model object is not new. Before Rails 5.1 form_tag Without model object - form_tag was used whrn we had to create to form without any model object providing URL endpoint to submit the form. <%= form_tag users_path do %> <%= text_field_tag :name %> <%= text_field_tag :email %> <%= submit_tag %> <% end %> Both helper methods used to create DOM of the form tag with necessary DOM content. <form action=\"/users\" accept-charset=\"UTF-8\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713\"/> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"/> <input type=\"text\" name=\"name\" id=\"name\"/> <input type=\"text\" name=\"email\" id=\"email\"/> <input type=\"submit\" name=\"commit\" value=\"Save Changes\" data-disable-with=\"Save Changes\"/> </form> After Rails 5.1 form_with withour a model object form_with provides an option to pass a URL to be used for the submit action. <%= form_with url: users_path do |form| %> <%= form.text_field :email%> <%= form.submit %> <% end %> This generates DOM given below. <form action=\"/users\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713;\"> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"> <input type=\"text\" name=\"email\"> <input type=\"submit\" name=\"commit\" value=\"Save \" data-disable-with=\"Save \" /> </form> form_with with a scope (prefix) new, we can see that above code, does not prefix input fields as it does when generated with model object. to generate input fields with some prefix, Rails provides scope option. <%= form_with url: users_path, scope: :user do |form| %> <%= form.text_field :name %> <%= form.text_field :email %> <%= form.submit %> <% end %> This generates DOM given below. <form action=\"/users\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"/> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713\"/> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"/> <input type=\"text\" name=\"user[name]\"/> <input type=\"text\" name=\"userp[email]\"/> <input type=\"submit\" name=\"commit\" value=\"Save User\" data-disable-with=\"Save User\"/> </form> form_with ajax submit events As we can see form_with adds data-remote attribute with value set to true . This makes sure that form is submitted with AJAX if unobtrusive javascript driver like rails-ujs is used. if your application uses rails-ujs , the form will be submitted via ajax, and it listens on following events. - ajax:success : This event is called when Ajax response is success. - ajax:error : This event is called when Ajax response is failure. Event can be binded on form as given below. $(document).on('ajax:success','#new_user', functionn(e) { console.log('form_with: succcessfully submitted form via ajax'); }); $(document).on('ajax:error', '#new_user', function(e){ console.log('form_with: error submitting form via ajax'); })","title":"Rails Form Expand"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/#rails-form_with-alternative-to-form_for-and-form_tag","text":"Rails 5.1 added form_with form helper method that provides capabilities of form_for and form_tag . Rails unified form_for and form_tag that provide similar interfaces to generate forms with form_with helper. - form_for was being used to generate for a new/existing model object. - form_tag was used to create form withour a model object by passing a URL to submit the form.","title":"Rails form_with - alternative to form_for and form_tag"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/#before-rails-51","text":"form_for with model object - form_for was used when we had to create a form for a model object. <%= form_for User.new do |form| %> <%= form.text_field :name%> <%= form.text_field :email%> <%= form.submit%> <% end %> This generates DOM shown below. <form class=\"new_user\" id=\"new_user\" actionn=\"/users\" accept-charset=\"UTF-8\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2712;\" /> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"/> <input type=\"text\" name=\"user[password]\" id=\"user_password\"/> <input type=\"text\" name=\"user[email]\" value=\"\" id=\"user_email\"/> <input type=\"submit\" name=\"submit\" value=\"create User\" data-disable-with=\"Create User\" /> </form>","title":"Before Rails 5.1"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/#behavior","text":"We can see Rails automatically assigns id attribute value to the new_user if record is new. id attribute is set to edit_user_<id> , where <id> is the primary key of users table. It fills out the input values if the model object is not new.","title":"Behavior:"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/#after-rails-51","text":"form_with with a model object <%= form_with model: @user do |form| %> <%= form.text_field :email %> <%= form.submit %> <% end %> This generates DOM given below. <form action=\"/users\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713\"/> <input type=\"hidden\" name=\"authenticaity_token\" value=\"token_value\"/> <input type=\"text\" name=\"email\" /> <input type=\"submit\" name=\"commit\" value=\"Save \" data-disable-with=\"SAVE \"> </form>","title":"After Rails 5.1"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/#behavior_1","text":"Automatic IDs for the form are gone. The above way of creating form works for both new and existing records. It fills out the input values if the model object is not new.","title":"Behavior:"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/#before-rails-51_1","text":"form_tag Without model object - form_tag was used whrn we had to create to form without any model object providing URL endpoint to submit the form. <%= form_tag users_path do %> <%= text_field_tag :name %> <%= text_field_tag :email %> <%= submit_tag %> <% end %> Both helper methods used to create DOM of the form tag with necessary DOM content. <form action=\"/users\" accept-charset=\"UTF-8\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713\"/> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"/> <input type=\"text\" name=\"name\" id=\"name\"/> <input type=\"text\" name=\"email\" id=\"email\"/> <input type=\"submit\" name=\"commit\" value=\"Save Changes\" data-disable-with=\"Save Changes\"/> </form>","title":"Before Rails 5.1"},{"location":"knowledge/web-development/ruby-on-rails/rails-form-expand/#after-rails-51_1","text":"form_with withour a model object form_with provides an option to pass a URL to be used for the submit action. <%= form_with url: users_path do |form| %> <%= form.text_field :email%> <%= form.submit %> <% end %> This generates DOM given below. <form action=\"/users\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713;\"> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"> <input type=\"text\" name=\"email\"> <input type=\"submit\" name=\"commit\" value=\"Save \" data-disable-with=\"Save \" /> </form> form_with with a scope (prefix) new, we can see that above code, does not prefix input fields as it does when generated with model object. to generate input fields with some prefix, Rails provides scope option. <%= form_with url: users_path, scope: :user do |form| %> <%= form.text_field :name %> <%= form.text_field :email %> <%= form.submit %> <% end %> This generates DOM given below. <form action=\"/users\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"/> <input name=\"utf8\" type=\"hidden\" value=\"&#x2713\"/> <input type=\"hidden\" name=\"authenticity_token\" value=\"token_value\"/> <input type=\"text\" name=\"user[name]\"/> <input type=\"text\" name=\"userp[email]\"/> <input type=\"submit\" name=\"commit\" value=\"Save User\" data-disable-with=\"Save User\"/> </form> form_with ajax submit events As we can see form_with adds data-remote attribute with value set to true . This makes sure that form is submitted with AJAX if unobtrusive javascript driver like rails-ujs is used. if your application uses rails-ujs , the form will be submitted via ajax, and it listens on following events. - ajax:success : This event is called when Ajax response is success. - ajax:error : This event is called when Ajax response is failure. Event can be binded on form as given below. $(document).on('ajax:success','#new_user', functionn(e) { console.log('form_with: succcessfully submitted form via ajax'); }); $(document).on('ajax:error', '#new_user', function(e){ console.log('form_with: error submitting form via ajax'); })","title":"After Rails 5.1"}]}